<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFL QUANT - Bet Tracker</title>
    <style>
        /* ============================================
           CSS VARIABLES & RESET
           NFL QUANT Dark Theme Color Palette
           ============================================ */
        :root {
            /* Primary colors */
            --bg-primary: #1a1a2e;
            --bg-card: #16213e;
            --bg-accent: #0f3460;
            --bg-input: #0d1b2a;

            /* Text colors */
            --text-primary: #e8e8e8;
            --text-secondary: #a0a0a0;
            --text-muted: #6c6c6c;

            /* Status colors */
            --status-won: #00d26a;
            --status-lost: #ff4757;
            --status-push: #ffa502;
            --status-pending: #747d8c;

            /* Accent colors */
            --accent-blue: #4facfe;
            --accent-purple: #7c3aed;
            --accent-gold: #f9ca24;

            /* Tier colors */
            --tier-premium: #f9ca24;
            --tier-standard: #4facfe;
            --tier-value: #a0a0a0;

            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;

            /* Border radius */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;

            /* Transitions */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.25s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        /* ============================================
           LAYOUT COMPONENTS
           ============================================ */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--spacing-md);
        }

        /* ============================================
           HEADER & SUMMARY STATS
           ============================================ */
        .header {
            background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-accent) 100%);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-lg);
            flex-wrap: wrap;
            gap: var(--spacing-md);
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        .header-title h1 {
            font-size: 1.75rem;
            font-weight: 700;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-title .version {
            background: var(--bg-accent);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .header-actions {
            display: flex;
            gap: var(--spacing-sm);
            flex-wrap: wrap;
        }

        /* Summary Stats Grid */
        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--spacing-md);
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: transform var(--transition-fast);
        }

        .stat-card:hover {
            transform: translateY(-2px);
        }

        .stat-card .label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: var(--spacing-xs);
        }

        .stat-card .value {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .stat-card .value.positive { color: var(--status-won); }
        .stat-card .value.negative { color: var(--status-lost); }
        .stat-card .value.neutral { color: var(--text-primary); }

        .stat-card .subtext {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: var(--spacing-xs);
        }

        /* ============================================
           TAB NAVIGATION
           ============================================ */
        .tab-nav {
            display: flex;
            gap: var(--spacing-xs);
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: var(--spacing-xs);
            margin-bottom: var(--spacing-lg);
            overflow-x: auto;
        }

        .tab-btn {
            padding: var(--spacing-sm) var(--spacing-lg);
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
            white-space: nowrap;
        }

        .tab-btn:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.05);
        }

        .tab-btn.active {
            background: var(--bg-accent);
            color: var(--text-primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* ============================================
           FILTER BUTTONS
           ============================================ */
        .filters-section {
            margin-bottom: var(--spacing-lg);
        }

        .filter-group {
            margin-bottom: var(--spacing-md);
        }

        .filter-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: var(--spacing-sm);
            display: block;
        }

        .filter-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-xs);
        }

        .filter-btn {
            padding: var(--spacing-xs) var(--spacing-md);
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--bg-card);
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
        }

        .filter-btn:hover {
            border-color: var(--accent-blue);
            color: var(--text-primary);
        }

        .filter-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        /* ============================================
           BUTTONS
           ============================================ */
        .btn {
            padding: var(--spacing-sm) var(--spacing-md);
            border: none;
            border-radius: var(--radius-sm);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-fast);
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(79, 172, 254, 0.3);
        }

        .btn-secondary {
            background: var(--bg-accent);
            color: var(--text-primary);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .btn-danger {
            background: var(--status-lost);
            color: white;
        }

        .btn-danger:hover {
            background: #ff6b7a;
        }

        .btn-small {
            padding: var(--spacing-xs) var(--spacing-sm);
            font-size: 0.75rem;
        }

        /* ============================================
           BET CARDS GRID
           ============================================ */
        .bets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
            gap: var(--spacing-md);
        }

        .bet-card {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            border: 1px solid rgba(255, 255, 255, 0.05);
            overflow: hidden;
            transition: all var(--transition-normal);
        }

        .bet-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.1);
        }

        /* Status indicator bar at top of card */
        .bet-card-status {
            height: 4px;
            width: 100%;
        }

        .bet-card-status.won { background: var(--status-won); }
        .bet-card-status.lost { background: var(--status-lost); }
        .bet-card-status.push { background: var(--status-push); }
        .bet-card-status.pending { background: var(--status-pending); }

        .bet-card-header {
            padding: var(--spacing-md);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .bet-card-title {
            flex: 1;
        }

        .bet-card-title .player-name {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: var(--spacing-xs);
        }

        .bet-card-title .bet-type {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .bet-card-badges {
            display: flex;
            gap: var(--spacing-xs);
            flex-wrap: wrap;
        }

        .badge {
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .badge-tier-premium {
            background: rgba(249, 202, 36, 0.2);
            color: var(--tier-premium);
        }

        .badge-tier-standard {
            background: rgba(79, 172, 254, 0.2);
            color: var(--tier-standard);
        }

        .badge-tier-value {
            background: rgba(160, 160, 160, 0.2);
            color: var(--tier-value);
        }

        .badge-week {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }

        .bet-card-body {
            padding: var(--spacing-md);
        }

        .bet-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--spacing-sm);
        }

        .bet-detail {
            display: flex;
            flex-direction: column;
        }

        .bet-detail .label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .bet-detail .value {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .bet-detail .value.highlight {
            color: var(--accent-blue);
        }

        .bet-card-footer {
            padding: var(--spacing-md);
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bet-result {
            font-size: 1.1rem;
            font-weight: 700;
        }

        .bet-result.positive { color: var(--status-won); }
        .bet-result.negative { color: var(--status-lost); }
        .bet-result.neutral { color: var(--status-push); }
        .bet-result.pending { color: var(--status-pending); }

        .bet-card-actions {
            display: flex;
            gap: var(--spacing-xs);
        }

        /* ============================================
           FORMS & MODALS
           ============================================ */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-md);
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            width: 100%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header {
            padding: var(--spacing-lg);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            font-size: 1.25rem;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .modal-body {
            padding: var(--spacing-lg);
        }

        .form-group {
            margin-bottom: var(--spacing-md);
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--spacing-md);
        }

        .form-label {
            display: block;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: var(--spacing-xs);
        }

        .form-input,
        .form-select,
        .form-textarea {
            width: 100%;
            padding: var(--spacing-sm) var(--spacing-md);
            background: var(--bg-input);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 0.9rem;
            transition: border-color var(--transition-fast);
        }

        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .form-textarea {
            min-height: 80px;
            resize: vertical;
        }

        .modal-footer {
            padding: var(--spacing-lg);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: flex-end;
            gap: var(--spacing-sm);
        }

        /* ============================================
           EMPTY STATE
           ============================================ */
        .empty-state {
            text-align: center;
            padding: var(--spacing-xl) var(--spacing-lg);
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: var(--spacing-md);
            opacity: 0.5;
        }

        .empty-state h3 {
            margin-bottom: var(--spacing-sm);
            color: var(--text-primary);
        }

        /* ============================================
           TOAST NOTIFICATIONS
           ============================================ */
        .toast-container {
            position: fixed;
            bottom: var(--spacing-lg);
            right: var(--spacing-lg);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .toast {
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            animation: slideIn 0.3s ease;
            min-width: 280px;
        }

        .toast.success { border-left: 3px solid var(--status-won); }
        .toast.error { border-left: 3px solid var(--status-lost); }
        .toast.info { border-left: 3px solid var(--accent-blue); }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* ============================================
           RESPONSIVE DESIGN
           ============================================ */
        @media (max-width: 768px) {
            .header-top {
                flex-direction: column;
                align-items: flex-start;
            }

            .summary-stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .bets-grid {
                grid-template-columns: 1fr;
            }

            .form-row {
                grid-template-columns: 1fr;
            }

            .bet-card-header {
                flex-direction: column;
                gap: var(--spacing-sm);
            }
        }

        /* ============================================
           ANALYTICS DASHBOARD STYLES (Part 2)
           ============================================ */

        /* Analytics Grid Layout */
        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .analytics-card {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .analytics-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-sm);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .analytics-card-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .analytics-card-value {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-xs);
        }

        .analytics-card-value.positive { color: var(--status-won); }
        .analytics-card-value.negative { color: var(--status-lost); }
        .analytics-card-value.neutral { color: var(--text-primary); }
        .analytics-card-value.warning { color: var(--status-push); }

        .analytics-card-subtitle {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        /* CSS Bar Charts */
        .bar-chart {
            margin-top: var(--spacing-md);
        }

        .bar-chart-item {
            margin-bottom: var(--spacing-sm);
        }

        .bar-chart-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: var(--spacing-xs);
        }

        .bar-chart-label-text {
            color: var(--text-secondary);
        }

        .bar-chart-label-value {
            font-weight: 600;
        }

        .bar-chart-track {
            height: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-sm);
            overflow: hidden;
        }

        .bar-chart-fill {
            height: 100%;
            border-radius: var(--radius-sm);
            transition: width 0.5s ease;
        }

        .bar-chart-fill.positive { background: linear-gradient(90deg, var(--status-won), #00ff88); }
        .bar-chart-fill.negative { background: linear-gradient(90deg, var(--status-lost), #ff6b7a); }
        .bar-chart-fill.neutral { background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple)); }
        .bar-chart-fill.warning { background: linear-gradient(90deg, var(--status-push), #ffbe00); }

        /* Horizontal Comparison Bars */
        .comparison-bars {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .comparison-bar-row {
            display: grid;
            grid-template-columns: 100px 1fr 60px;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .comparison-bar-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .comparison-bar-container {
            height: 24px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-sm);
            overflow: hidden;
            position: relative;
        }

        .comparison-bar {
            height: 100%;
            display: flex;
            align-items: center;
            padding-left: var(--spacing-sm);
            font-size: 0.7rem;
            font-weight: 600;
            color: white;
            transition: width 0.5s ease;
        }

        .comparison-bar-value {
            font-size: 0.85rem;
            font-weight: 600;
            text-align: right;
        }

        /* Calibration Chart */
        .calibration-chart {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: var(--spacing-xs);
            margin-top: var(--spacing-md);
        }

        .calibration-bucket {
            text-align: center;
        }

        .calibration-bucket-bar {
            height: 80px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-sm);
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            overflow: hidden;
            position: relative;
            margin-bottom: var(--spacing-xs);
        }

        .calibration-expected {
            position: absolute;
            width: 100%;
            height: 2px;
            background: var(--accent-blue);
            left: 0;
        }

        .calibration-actual {
            width: 100%;
            transition: height 0.5s ease;
        }

        .calibration-bucket-label {
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .calibration-bucket-value {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        /* Analytics Tables */
        .analytics-table-container {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            border: 1px solid rgba(255, 255, 255, 0.05);
            overflow-x: auto;
        }

        .analytics-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        .analytics-table th {
            text-align: left;
            padding: var(--spacing-sm) var(--spacing-md);
            background: rgba(0, 0, 0, 0.2);
            color: var(--text-secondary);
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .analytics-table td {
            padding: var(--spacing-sm) var(--spacing-md);
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .analytics-table tr:hover td {
            background: rgba(255, 255, 255, 0.02);
        }

        .analytics-table .positive { color: var(--status-won); }
        .analytics-table .negative { color: var(--status-lost); }
        .analytics-table .neutral { color: var(--text-primary); }

        /* Kelly Adherence Indicator */
        .kelly-indicator {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
        }

        .kelly-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .kelly-dot.under { background: var(--status-won); }
        .kelly-dot.over { background: var(--status-lost); }
        .kelly-dot.optimal { background: var(--accent-blue); }

        .kelly-legend {
            display: flex;
            gap: var(--spacing-md);
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: var(--spacing-sm);
        }

        .kelly-legend-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        /* Section Headers */
        .analytics-section-header {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-sm);
            border-bottom: 2px solid var(--bg-accent);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .analytics-section-header .icon {
            font-size: 1.2rem;
        }

        /* Wide Card */
        .analytics-card.wide {
            grid-column: span 2;
        }

        @media (max-width: 768px) {
            .analytics-card.wide {
                grid-column: span 1;
            }

            .comparison-bar-row {
                grid-template-columns: 80px 1fr 50px;
            }
        }

        /* Mini Sparkline (CSS only) */
        .sparkline {
            display: flex;
            align-items: flex-end;
            gap: 2px;
            height: 30px;
            margin-top: var(--spacing-sm);
        }

        .sparkline-bar {
            flex: 1;
            min-width: 4px;
            max-width: 12px;
            border-radius: 2px 2px 0 0;
            transition: height 0.3s ease;
        }

        /* Gauge Chart */
        .gauge-container {
            position: relative;
            width: 120px;
            height: 60px;
            margin: var(--spacing-md) auto;
        }

        .gauge-background {
            position: absolute;
            width: 120px;
            height: 60px;
            border-radius: 60px 60px 0 0;
            background: rgba(255, 255, 255, 0.05);
            overflow: hidden;
        }

        .gauge-fill {
            position: absolute;
            width: 120px;
            height: 60px;
            border-radius: 60px 60px 0 0;
            background: linear-gradient(90deg, var(--status-lost), var(--status-push), var(--status-won));
            transform-origin: bottom center;
            transition: transform 0.5s ease;
        }

        .gauge-cover {
            position: absolute;
            width: 80px;
            height: 40px;
            background: var(--bg-card);
            border-radius: 40px 40px 0 0;
            bottom: 0;
            left: 20px;
        }

        .gauge-needle {
            position: absolute;
            width: 4px;
            height: 35px;
            background: var(--text-primary);
            bottom: 0;
            left: 58px;
            transform-origin: bottom center;
            border-radius: 2px;
            transition: transform 0.5s ease;
        }

        .gauge-value {
            position: absolute;
            bottom: -25px;
            width: 100%;
            text-align: center;
            font-size: 0.9rem;
            font-weight: 600;
        }

        /* ============================================
           PART 3: QUICK RESULT BUTTONS
           ============================================ */
        .quick-result-buttons {
            display: flex;
            gap: var(--spacing-xs);
            margin-top: var(--spacing-sm);
        }

        .result-btn {
            flex: 1;
            padding: var(--spacing-xs) var(--spacing-sm);
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--bg-input);
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
            text-transform: uppercase;
        }

        .result-btn:hover {
            transform: translateY(-1px);
        }

        .result-btn.won:hover {
            background: var(--status-won);
            border-color: var(--status-won);
            color: white;
        }

        .result-btn.lost:hover {
            background: var(--status-lost);
            border-color: var(--status-lost);
            color: white;
        }

        .result-btn.push:hover {
            background: var(--status-push);
            border-color: var(--status-push);
            color: white;
        }

        .result-btn.void:hover {
            background: var(--text-muted);
            border-color: var(--text-muted);
            color: white;
        }

        /* ============================================
           PART 3: BANKROLL CHART
           ============================================ */
        .bankroll-chart-container {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            border: 1px solid rgba(255, 255, 255, 0.05);
            margin-bottom: var(--spacing-lg);
        }

        .bankroll-chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
        }

        .bankroll-chart-title {
            font-size: 1rem;
            font-weight: 600;
        }

        .bankroll-chart-legend {
            display: flex;
            gap: var(--spacing-md);
            font-size: 0.75rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-dot.actual { background: var(--accent-blue); }
        .legend-dot.kelly { background: var(--status-push); }

        .bankroll-chart {
            position: relative;
            height: 200px;
            width: 100%;
        }

        .bankroll-chart svg {
            width: 100%;
            height: 100%;
        }

        .chart-grid-line {
            stroke: rgba(255, 255, 255, 0.05);
            stroke-width: 1;
        }

        .chart-zero-line {
            stroke: rgba(255, 255, 255, 0.2);
            stroke-width: 1;
            stroke-dasharray: 4, 4;
        }

        .chart-line {
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .chart-line.actual {
            stroke: var(--accent-blue);
        }

        .chart-line.kelly {
            stroke: var(--status-push);
            stroke-dasharray: 5, 5;
        }

        .chart-area {
            opacity: 0.1;
        }

        .chart-area.actual { fill: var(--accent-blue); }
        .chart-area.kelly { fill: var(--status-push); }

        .chart-point {
            fill: var(--bg-card);
            stroke-width: 2;
            cursor: pointer;
            transition: r 0.2s ease;
        }

        .chart-point.actual { stroke: var(--accent-blue); }
        .chart-point.kelly { stroke: var(--status-push); }

        .chart-point:hover {
            r: 6;
        }

        .chart-tooltip {
            position: absolute;
            background: var(--bg-accent);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-sm);
            padding: var(--spacing-sm);
            font-size: 0.75rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 100;
            white-space: nowrap;
        }

        .chart-tooltip.visible {
            opacity: 1;
        }

        .chart-y-label {
            position: absolute;
            left: 0;
            font-size: 0.65rem;
            color: var(--text-muted);
            transform: translateY(-50%);
        }

        .chart-x-labels {
            display: flex;
            justify-content: space-between;
            margin-top: var(--spacing-xs);
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        /* ============================================
           PART 3: TAKE BET MODAL ENHANCEMENTS
           ============================================ */
        .capture-bet-summary {
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .capture-bet-summary .player {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: var(--spacing-xs);
        }

        .capture-bet-summary .details {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--spacing-sm);
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .capture-bet-summary .detail-item {
            display: flex;
            flex-direction: column;
        }

        .capture-bet-summary .detail-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .capture-bet-summary .detail-value {
            font-weight: 500;
            color: var(--text-primary);
        }

        .capture-bet-summary .detail-value.highlight {
            color: var(--accent-blue);
        }

        .stake-calculator {
            background: rgba(79, 172, 254, 0.1);
            border: 1px solid rgba(79, 172, 254, 0.2);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            margin-top: var(--spacing-md);
        }

        .stake-calculator-title {
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: var(--spacing-sm);
            color: var(--accent-blue);
        }

        .stake-presets {
            display: flex;
            gap: var(--spacing-xs);
            flex-wrap: wrap;
        }

        .stake-preset-btn {
            padding: var(--spacing-xs) var(--spacing-sm);
            background: var(--bg-input);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-sm);
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .stake-preset-btn:hover {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        .stake-preset-btn.kelly {
            border-color: var(--status-push);
            color: var(--status-push);
        }

        .stake-preset-btn.kelly:hover {
            background: var(--status-push);
            color: white;
        }

        /* Payout preview */
        .payout-preview {
            margin-top: var(--spacing-md);
            padding: var(--spacing-md);
            background: rgba(0, 210, 106, 0.1);
            border: 1px solid rgba(0, 210, 106, 0.2);
            border-radius: var(--radius-md);
            text-align: center;
        }

        .payout-preview-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: var(--spacing-xs);
        }

        .payout-preview-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--status-won);
        }

        /* Hidden file input for imports */
        .hidden-input {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ============================================
             HEADER WITH SUMMARY STATS
             ============================================ -->
        <header class="header">
            <div class="header-top">
                <div class="header-title">
                    <h1>NFL QUANT Bet Tracker</h1>
                    <span class="version">v1.0</span>
                </div>
                <div class="header-actions">
                    <button class="btn btn-primary" onclick="openAddBetModal()">
                        + Add Bet
                    </button>
                    <button class="btn btn-secondary" onclick="exportCSV()">
                        Export CSV
                    </button>
                    <button class="btn btn-secondary" onclick="exportJSON()">
                        Backup JSON
                    </button>
                    <button class="btn btn-secondary" onclick="document.getElementById('importFile').click()">
                        Import
                    </button>
                    <input type="file" id="importFile" class="hidden-input" accept=".json" onchange="importJSON(event)">
                </div>
            </div>

            <!-- Summary Statistics -->
            <div class="summary-stats">
                <div class="stat-card">
                    <div class="label">Total P/L</div>
                    <div class="value neutral" id="stat-total-pl">$0.00</div>
                    <div class="subtext" id="stat-total-wagered">$0 wagered</div>
                </div>
                <div class="stat-card">
                    <div class="label">ROI</div>
                    <div class="value neutral" id="stat-roi">0.0%</div>
                    <div class="subtext">All time</div>
                </div>
                <div class="stat-card">
                    <div class="label">Record</div>
                    <div class="value neutral" id="stat-record">0-0-0</div>
                    <div class="subtext" id="stat-win-rate">0% win rate</div>
                </div>
                <div class="stat-card">
                    <div class="label">Avg CLV</div>
                    <div class="value neutral" id="stat-clv">0.0%</div>
                    <div class="subtext">Closing line value</div>
                </div>
                <div class="stat-card">
                    <div class="label">Pending</div>
                    <div class="value neutral" id="stat-pending">0</div>
                    <div class="subtext" id="stat-pending-risk">$0 at risk</div>
                </div>
                <div class="stat-card">
                    <div class="label">Avg EV</div>
                    <div class="value neutral" id="stat-avg-ev">0.0%</div>
                    <div class="subtext">Expected value</div>
                </div>
            </div>
        </header>

        <!-- ============================================
             TAB NAVIGATION
             ============================================ -->
        <nav class="tab-nav">
            <button class="tab-btn active" data-tab="dashboard">Dashboard</button>
            <button class="tab-btn" data-tab="active">Active Bets</button>
            <button class="tab-btn" data-tab="history">History</button>
            <button class="tab-btn" data-tab="analytics">Analytics</button>
        </nav>

        <!-- ============================================
             TAB CONTENT: DASHBOARD
             ============================================ -->
        <div class="tab-content active" id="tab-dashboard">
            <!-- Quick Filters -->
            <div class="filters-section">
                <div class="filter-group">
                    <span class="filter-label">Quick Filters</span>
                    <div class="filter-buttons">
                        <button class="filter-btn active" data-filter="all">All</button>
                        <button class="filter-btn" data-filter="pending">Pending</button>
                        <button class="filter-btn" data-filter="won">Won</button>
                        <button class="filter-btn" data-filter="lost">Lost</button>
                    </div>
                </div>
                <div class="filter-group">
                    <span class="filter-label">By Tier</span>
                    <div class="filter-buttons" id="tier-filters">
                        <button class="filter-btn active" data-tier="all">All Tiers</button>
                        <button class="filter-btn" data-tier="premium">Premium</button>
                        <button class="filter-btn" data-tier="standard">Standard</button>
                        <button class="filter-btn" data-tier="value">Value</button>
                    </div>
                </div>
                <div class="filter-group">
                    <span class="filter-label">By Week</span>
                    <div class="filter-buttons" id="week-filters">
                        <button class="filter-btn active" data-week="all">All Weeks</button>
                        <!-- Dynamically populated -->
                    </div>
                </div>
                <div class="filter-group">
                    <span class="filter-label">By Type</span>
                    <div class="filter-buttons" id="type-filters">
                        <button class="filter-btn active" data-type="all">All Types</button>
                        <button class="filter-btn" data-type="player_receptions">Receptions</button>
                        <button class="filter-btn" data-type="player_reception_yds">Rec Yards</button>
                        <button class="filter-btn" data-type="player_rush_yds">Rush Yards</button>
                        <button class="filter-btn" data-type="player_rush_attempts">Rush Att</button>
                    </div>
                </div>
            </div>

            <!-- Bets Grid -->
            <div class="bets-grid" id="dashboard-bets">
                <!-- Bet cards populated by JavaScript -->
            </div>

            <div class="empty-state" id="dashboard-empty" style="display: none;">
                <div class="empty-state-icon">ðŸ“Š</div>
                <h3>No bets found</h3>
                <p>Add your first bet or adjust filters to see results.</p>
            </div>
        </div>

        <!-- ============================================
             TAB CONTENT: ACTIVE BETS
             ============================================ -->
        <div class="tab-content" id="tab-active">
            <div class="bets-grid" id="active-bets">
                <!-- Active bet cards populated by JavaScript -->
            </div>

            <div class="empty-state" id="active-empty" style="display: none;">
                <div class="empty-state-icon">ðŸŽ¯</div>
                <h3>No active bets</h3>
                <p>All your pending bets will appear here.</p>
            </div>
        </div>

        <!-- ============================================
             TAB CONTENT: HISTORY
             ============================================ -->
        <div class="tab-content" id="tab-history">
            <div class="bets-grid" id="history-bets">
                <!-- Settled bet cards populated by JavaScript -->
            </div>

            <div class="empty-state" id="history-empty" style="display: none;">
                <div class="empty-state-icon">ðŸ“œ</div>
                <h3>No betting history</h3>
                <p>Your settled bets will appear here.</p>
            </div>
        </div>

        <!-- ============================================
             TAB CONTENT: ANALYTICS DASHBOARD (Part 2)
             ============================================ -->
        <div class="tab-content" id="tab-analytics">
            <!-- Bankroll Chart (Part 3) -->
            <div class="bankroll-chart-container" id="bankroll-chart-section">
                <div class="bankroll-chart-header">
                    <span class="bankroll-chart-title">Bankroll Over Time</span>
                    <div class="bankroll-chart-legend">
                        <div class="legend-item">
                            <div class="legend-dot actual"></div>
                            <span>Actual P/L</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot kelly"></div>
                            <span>If Kelly Sized</span>
                        </div>
                    </div>
                </div>
                <div class="bankroll-chart" id="bankroll-chart">
                    <svg viewBox="0 0 800 200" preserveAspectRatio="none">
                        <!-- Grid lines -->
                        <g class="chart-grid"></g>
                        <!-- Zero line -->
                        <line class="chart-zero-line" x1="0" y1="100" x2="800" y2="100"></line>
                        <!-- Area fills -->
                        <path class="chart-area actual" d=""></path>
                        <path class="chart-area kelly" d=""></path>
                        <!-- Lines -->
                        <path class="chart-line actual" d=""></path>
                        <path class="chart-line kelly" d=""></path>
                        <!-- Points -->
                        <g class="chart-points-actual"></g>
                        <g class="chart-points-kelly"></g>
                    </svg>
                    <div class="chart-tooltip" id="chart-tooltip"></div>
                </div>
                <div class="chart-x-labels" id="chart-x-labels">
                    <!-- X-axis labels populated by JS -->
                </div>
            </div>

            <!-- Key Metrics Row -->
            <h3 class="analytics-section-header">
                <span class="icon">ðŸ“Š</span> Key Performance Metrics
            </h3>
            <div class="analytics-grid" id="analytics-metrics">
                <!-- Overall ROI Card -->
                <div class="analytics-card">
                    <div class="analytics-card-header">
                        <span class="analytics-card-title">Overall ROI</span>
                    </div>
                    <div class="analytics-card-value neutral" id="analytics-roi">0.0%</div>
                    <div class="analytics-card-subtitle" id="analytics-roi-subtitle">0 settled bets</div>
                    <div class="sparkline" id="roi-sparkline">
                        <!-- Sparkline bars populated by JS -->
                    </div>
                </div>

                <!-- CLV Card -->
                <div class="analytics-card">
                    <div class="analytics-card-header">
                        <span class="analytics-card-title">Closing Line Value</span>
                    </div>
                    <div class="analytics-card-value neutral" id="analytics-clv">0.0%</div>
                    <div class="analytics-card-subtitle" id="analytics-clv-subtitle">0% beat closing line</div>
                    <div class="gauge-container">
                        <div class="gauge-background"></div>
                        <div class="gauge-fill"></div>
                        <div class="gauge-cover"></div>
                        <div class="gauge-needle" id="clv-needle"></div>
                        <div class="gauge-value" id="clv-gauge-value">0%</div>
                    </div>
                </div>

                <!-- Brier Score Card -->
                <div class="analytics-card">
                    <div class="analytics-card-header">
                        <span class="analytics-card-title">Model Calibration</span>
                    </div>
                    <div class="analytics-card-value neutral" id="analytics-brier">0.000</div>
                    <div class="analytics-card-subtitle">Brier Score (lower is better)</div>
                    <div class="bar-chart">
                        <div class="bar-chart-item">
                            <div class="bar-chart-label">
                                <span class="bar-chart-label-text">vs Random (0.25)</span>
                                <span class="bar-chart-label-value" id="brier-vs-random">-</span>
                            </div>
                            <div class="bar-chart-track">
                                <div class="bar-chart-fill neutral" id="brier-bar" style="width: 50%;"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Kelly Adherence Card -->
                <div class="analytics-card">
                    <div class="analytics-card-header">
                        <span class="analytics-card-title">Kelly Adherence</span>
                    </div>
                    <div class="analytics-card-value neutral" id="analytics-kelly">0%</div>
                    <div class="analytics-card-subtitle" id="analytics-kelly-subtitle">Avg stake vs suggested</div>
                    <div class="kelly-legend">
                        <div class="kelly-legend-item">
                            <div class="kelly-dot under"></div>
                            <span>Under-bet</span>
                        </div>
                        <div class="kelly-legend-item">
                            <div class="kelly-dot optimal"></div>
                            <span>Optimal</span>
                        </div>
                        <div class="kelly-legend-item">
                            <div class="kelly-dot over"></div>
                            <span>Over-bet</span>
                        </div>
                    </div>
                    <div class="bar-chart" id="kelly-distribution">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>

            <!-- ROI by Tier Section -->
            <h3 class="analytics-section-header">
                <span class="icon">ðŸ†</span> Performance by Tier
            </h3>
            <div class="analytics-grid">
                <div class="analytics-card wide">
                    <div class="comparison-bars" id="tier-roi-bars">
                        <!-- Populated by JS -->
                    </div>
                </div>

                <!-- Expected vs Actual by Tier -->
                <div class="analytics-card">
                    <div class="analytics-card-header">
                        <span class="analytics-card-title">Expected vs Actual</span>
                    </div>
                    <div class="calibration-chart" id="tier-calibration">
                        <!-- Populated by JS -->
                    </div>
                    <div class="analytics-card-subtitle" style="margin-top: 8px; text-align: center;">
                        Blue line = expected win rate
                    </div>
                </div>
            </div>

            <!-- ROI by Market Type Section -->
            <h3 class="analytics-section-header">
                <span class="icon">ðŸŽ¯</span> Performance by Market
            </h3>
            <div class="analytics-grid">
                <div class="analytics-card wide">
                    <div class="comparison-bars" id="type-roi-bars">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>

            <!-- Weekly Breakdown Table -->
            <h3 class="analytics-section-header">
                <span class="icon">ðŸ“…</span> Weekly Breakdown
            </h3>
            <div class="analytics-table-container">
                <table class="analytics-table" id="weekly-breakdown-table">
                    <thead>
                        <tr>
                            <th>Week</th>
                            <th>Bets</th>
                            <th>Record</th>
                            <th>Win %</th>
                            <th>Wagered</th>
                            <th>P/L</th>
                            <th>ROI</th>
                            <th>Avg EV</th>
                            <th>CLV %</th>
                        </tr>
                    </thead>
                    <tbody id="weekly-breakdown-body">
                        <!-- Populated by JS -->
                    </tbody>
                    <tfoot id="weekly-breakdown-footer">
                        <!-- Totals row populated by JS -->
                    </tfoot>
                </table>
            </div>

            <!-- Monthly Breakdown Table (if spanning months) -->
            <div id="monthly-breakdown-section" style="margin-top: var(--spacing-lg);">
                <h3 class="analytics-section-header">
                    <span class="icon">ðŸ“†</span> Monthly Summary
                </h3>
                <div class="analytics-table-container">
                    <table class="analytics-table" id="monthly-breakdown-table">
                        <thead>
                            <tr>
                                <th>Month</th>
                                <th>Bets</th>
                                <th>Record</th>
                                <th>Win %</th>
                                <th>Wagered</th>
                                <th>P/L</th>
                                <th>ROI</th>
                            </tr>
                        </thead>
                        <tbody id="monthly-breakdown-body">
                            <!-- Populated by JS -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Empty State for Analytics -->
            <div class="empty-state" id="analytics-empty" style="display: none;">
                <div class="empty-state-icon">ðŸ“ˆ</div>
                <h3>No Data Yet</h3>
                <p>Add and settle some bets to see analytics.</p>
            </div>
        </div>
    </div>

    <!-- ============================================
         ADD/EDIT BET MODAL
         ============================================ -->
    <div class="modal-overlay" id="bet-modal">
        <div class="modal">
            <div class="modal-header">
                <h2 id="modal-title">Add New Bet</h2>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <form id="bet-form">
                    <input type="hidden" id="bet-id">

                    <!-- Row 1: Week & Game -->
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Week *</label>
                            <input type="number" class="form-input" id="bet-week" min="1" max="18" required>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Game (e.g., KC @ BUF)</label>
                            <input type="text" class="form-input" id="bet-game" placeholder="KC @ BUF">
                        </div>
                    </div>

                    <!-- Row 2: Selection & Type -->
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Player/Selection *</label>
                            <input type="text" class="form-input" id="bet-selection" placeholder="Travis Kelce UNDER" required>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Bet Type *</label>
                            <select class="form-select" id="bet-type" required>
                                <option value="">Select type...</option>
                                <option value="player_receptions">Player Receptions</option>
                                <option value="player_reception_yds">Player Reception Yards</option>
                                <option value="player_rush_yds">Player Rush Yards</option>
                                <option value="player_rush_attempts">Player Rush Attempts</option>
                                <option value="player_pass_yds">Player Pass Yards</option>
                                <option value="player_pass_tds">Player Pass TDs</option>
                                <option value="other">Other</option>
                            </select>
                        </div>
                    </div>

                    <!-- Row 3: Line & Odds -->
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Line *</label>
                            <input type="number" class="form-input" id="bet-line" step="0.5" required placeholder="4.5">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Odds (American) *</label>
                            <input type="number" class="form-input" id="bet-odds" required placeholder="-110">
                        </div>
                    </div>

                    <!-- Row 4: Probabilities -->
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Implied Prob %</label>
                            <input type="number" class="form-input" id="bet-implied-prob" step="0.1" placeholder="52.4">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Model Prob %</label>
                            <input type="number" class="form-input" id="bet-model-prob" step="0.1" placeholder="65.0">
                        </div>
                    </div>

                    <!-- Row 5: EV & Tier -->
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">EV %</label>
                            <input type="number" class="form-input" id="bet-ev" step="0.1" placeholder="12.5">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Tier</label>
                            <select class="form-select" id="bet-tier">
                                <option value="standard">Standard</option>
                                <option value="premium">Premium</option>
                                <option value="value">Value</option>
                            </select>
                        </div>
                    </div>

                    <!-- Row 6: Stakes -->
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Kelly Suggested ($)</label>
                            <input type="number" class="form-input" id="bet-kelly" step="0.01" placeholder="10.00">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Actual Stake ($) *</label>
                            <input type="number" class="form-input" id="bet-stake" step="0.01" required placeholder="5.00">
                        </div>
                    </div>

                    <!-- Row 7: Result fields (for editing) -->
                    <div class="form-row" id="result-fields" style="display: none;">
                        <div class="form-group">
                            <label class="form-label">Result</label>
                            <select class="form-select" id="bet-result">
                                <option value="pending">Pending</option>
                                <option value="won">Won</option>
                                <option value="lost">Lost</option>
                                <option value="push">Push</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Closing Line</label>
                            <input type="number" class="form-input" id="bet-closing-line" step="0.5" placeholder="4.0">
                        </div>
                    </div>

                    <!-- Notes -->
                    <div class="form-group">
                        <label class="form-label">Notes</label>
                        <textarea class="form-textarea" id="bet-notes" placeholder="Any additional notes..."></textarea>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveBet()">Save Bet</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toast-container"></div>

    <!-- ============================================
         JAVASCRIPT: IndexedDB & Core Functions
         ============================================ -->
    <script>
        /* ============================================
           INDEXEDDB WRAPPER
           Provides async CRUD operations for bet storage
           ============================================ */

        const DB_NAME = 'NFLQuantBetTracker';
        const DB_VERSION = 1;
        const STORE_NAME = 'bets';

        let db = null;

        /**
         * Initialize IndexedDB connection
         * Creates object store if it doesn't exist
         */
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => {
                    console.error('IndexedDB error:', request.error);
                    reject(request.error);
                };

                request.onsuccess = () => {
                    db = request.result;
                    console.log('IndexedDB connected successfully');
                    resolve(db);
                };

                // Create object store on first run or version upgrade
                request.onupgradeneeded = (event) => {
                    const database = event.target.result;

                    if (!database.objectStoreNames.contains(STORE_NAME)) {
                        const store = database.createObjectStore(STORE_NAME, {
                            keyPath: 'id',
                            autoIncrement: false
                        });

                        // Create indexes for common queries
                        store.createIndex('week', 'week', { unique: false });
                        store.createIndex('result', 'result', { unique: false });
                        store.createIndex('tier', 'tier', { unique: false });
                        store.createIndex('bet_type', 'bet_type', { unique: false });
                        store.createIndex('timestamp', 'timestamp', { unique: false });

                        console.log('Object store created with indexes');
                    }
                };
            });
        }

        /**
         * BET DATA MODEL
         * Schema for bet objects stored in IndexedDB
         *
         * {
         *   id: string,              // Unique identifier (UUID)
         *   timestamp: number,       // Unix timestamp when bet was placed
         *   week: number,            // NFL week number (1-18)
         *   game: string,            // Game matchup (e.g., "KC @ BUF")
         *   selection: string,       // Bet selection (e.g., "Travis Kelce UNDER")
         *   bet_type: string,        // Market type (player_receptions, etc.)
         *   line: number,            // Bet line (e.g., 4.5)
         *   odds: number,            // American odds (e.g., -110)
         *   implied_prob: number,    // Implied probability from odds (%)
         *   model_prob: number,      // Model's predicted probability (%)
         *   ev_pct: number,          // Expected value percentage
         *   tier: string,            // Bet tier (premium, standard, value)
         *   kelly_suggested: number, // Kelly criterion suggested stake ($)
         *   actual_stake: number,    // Actual amount wagered ($)
         *   closing_line: number,    // Line at close (for CLV calculation)
         *   result: string,          // Bet result (pending, won, lost, push)
         *   payout: number,          // Amount won/lost ($)
         *   notes: string            // Additional notes
         * }
         */

        /**
         * Generate a UUID for new bets
         */
        function generateId() {
            return 'bet_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        /**
         * Calculate implied probability from American odds
         */
        function oddsToImpliedProb(odds) {
            if (odds < 0) {
                return Math.abs(odds) / (Math.abs(odds) + 100) * 100;
            } else {
                return 100 / (odds + 100) * 100;
            }
        }

        /**
         * Calculate payout from stake and odds
         */
        function calculatePayout(stake, odds, result) {
            if (result === 'pending') return 0;
            if (result === 'push') return 0;
            if (result === 'lost') return -stake;

            // Won
            if (odds < 0) {
                return stake * (100 / Math.abs(odds));
            } else {
                return stake * (odds / 100);
            }
        }

        /* ============================================
           CRUD OPERATIONS
           ============================================ */

        /**
         * Add a new bet to the database
         * @param {Object} betData - Bet data (without id)
         * @returns {Promise<Object>} - The created bet with id
         */
        async function addBet(betData) {
            return new Promise((resolve, reject) => {
                const bet = {
                    id: generateId(),
                    timestamp: Date.now(),
                    ...betData,
                    // Calculate implied prob if not provided
                    implied_prob: betData.implied_prob || oddsToImpliedProb(betData.odds),
                    // Initialize result fields
                    result: betData.result || 'pending',
                    payout: betData.payout || 0,
                    closing_line: betData.closing_line || null
                };

                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.add(bet);

                request.onsuccess = () => {
                    console.log('Bet added:', bet.id);
                    resolve(bet);
                };

                request.onerror = () => {
                    console.error('Error adding bet:', request.error);
                    reject(request.error);
                };
            });
        }

        /**
         * Update an existing bet
         * @param {Object} bet - Complete bet object with id
         * @returns {Promise<Object>} - The updated bet
         */
        async function updateBet(bet) {
            return new Promise((resolve, reject) => {
                // Recalculate payout if result changed
                if (bet.result !== 'pending') {
                    bet.payout = calculatePayout(bet.actual_stake, bet.odds, bet.result);
                }

                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(bet);

                request.onsuccess = () => {
                    console.log('Bet updated:', bet.id);
                    resolve(bet);
                };

                request.onerror = () => {
                    console.error('Error updating bet:', request.error);
                    reject(request.error);
                };
            });
        }

        /**
         * Delete a bet by id
         * @param {string} id - Bet id to delete
         * @returns {Promise<void>}
         */
        async function deleteBet(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.delete(id);

                request.onsuccess = () => {
                    console.log('Bet deleted:', id);
                    resolve();
                };

                request.onerror = () => {
                    console.error('Error deleting bet:', request.error);
                    reject(request.error);
                };
            });
        }

        /**
         * Get all bets from the database
         * @returns {Promise<Array>} - Array of all bets
         */
        async function getAllBets() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();

                request.onsuccess = () => {
                    // Sort by timestamp descending (newest first)
                    const bets = request.result.sort((a, b) => b.timestamp - a.timestamp);
                    resolve(bets);
                };

                request.onerror = () => {
                    console.error('Error getting bets:', request.error);
                    reject(request.error);
                };
            });
        }

        /**
         * Get a single bet by id
         * @param {string} id - Bet id
         * @returns {Promise<Object>} - The bet object
         */
        async function getBet(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(id);

                request.onsuccess = () => {
                    resolve(request.result);
                };

                request.onerror = () => {
                    reject(request.error);
                };
            });
        }

        /* ============================================
           EXPORT/IMPORT FUNCTIONS
           ============================================ */

        /**
         * Export all bets to CSV format
         */
        async function exportCSV() {
            const bets = await getAllBets();

            if (bets.length === 0) {
                showToast('No bets to export', 'info');
                return;
            }

            // CSV header
            const headers = [
                'id', 'timestamp', 'date', 'week', 'game', 'selection', 'bet_type',
                'line', 'odds', 'implied_prob', 'model_prob', 'ev_pct', 'tier',
                'kelly_suggested', 'actual_stake', 'closing_line', 'result', 'payout', 'notes'
            ];

            // Build CSV rows
            const rows = bets.map(bet => {
                return [
                    bet.id,
                    bet.timestamp,
                    new Date(bet.timestamp).toISOString().split('T')[0],
                    bet.week,
                    `"${bet.game || ''}"`,
                    `"${bet.selection}"`,
                    bet.bet_type,
                    bet.line,
                    bet.odds,
                    bet.implied_prob?.toFixed(1) || '',
                    bet.model_prob?.toFixed(1) || '',
                    bet.ev_pct?.toFixed(1) || '',
                    bet.tier,
                    bet.kelly_suggested?.toFixed(2) || '',
                    bet.actual_stake?.toFixed(2) || '',
                    bet.closing_line || '',
                    bet.result,
                    bet.payout?.toFixed(2) || '',
                    `"${(bet.notes || '').replace(/"/g, '""')}"`
                ].join(',');
            });

            const csv = [headers.join(','), ...rows].join('\n');

            // Download file
            downloadFile(csv, `nfl_quant_bets_${formatDate(new Date())}.csv`, 'text/csv');
            showToast('CSV exported successfully', 'success');
        }

        /**
         * Export all bets to JSON for backup
         */
        async function exportJSON() {
            const bets = await getAllBets();

            const backup = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                betCount: bets.length,
                bets: bets
            };

            const json = JSON.stringify(backup, null, 2);
            downloadFile(json, `nfl_quant_backup_${formatDate(new Date())}.json`, 'application/json');
            showToast('Backup exported successfully', 'success');
        }

        /**
         * Import bets from JSON backup
         */
        async function importJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const data = JSON.parse(text);

                if (!data.bets || !Array.isArray(data.bets)) {
                    throw new Error('Invalid backup file format');
                }

                // Import each bet
                let imported = 0;
                let skipped = 0;

                for (const bet of data.bets) {
                    try {
                        // Check if bet already exists
                        const existing = await getBet(bet.id);
                        if (existing) {
                            skipped++;
                            continue;
                        }

                        // Add bet directly (preserving id)
                        const transaction = db.transaction([STORE_NAME], 'readwrite');
                        const store = transaction.objectStore(STORE_NAME);
                        await new Promise((resolve, reject) => {
                            const request = store.add(bet);
                            request.onsuccess = () => resolve();
                            request.onerror = () => reject(request.error);
                        });
                        imported++;
                    } catch (e) {
                        console.error('Error importing bet:', e);
                        skipped++;
                    }
                }

                showToast(`Imported ${imported} bets (${skipped} skipped)`, 'success');
                await refreshUI();

            } catch (e) {
                console.error('Import error:', e);
                showToast('Error importing backup: ' + e.message, 'error');
            }

            // Reset file input
            event.target.value = '';
        }

        /**
         * Helper: Download a file
         */
        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        /**
         * Helper: Format date as YYYY-MM-DD
         */
        function formatDate(date) {
            return date.toISOString().split('T')[0];
        }

        /* ============================================
           UI RENDERING FUNCTIONS
           ============================================ */

        // Current filter state
        let currentFilters = {
            result: 'all',
            tier: 'all',
            week: 'all',
            type: 'all'
        };

        /**
         * Render a single bet card
         */
        function renderBetCard(bet) {
            const resultClass = bet.result;
            const tierClass = `badge-tier-${bet.tier}`;

            // Format payout display
            let payoutDisplay = '';
            let payoutClass = 'pending';

            if (bet.result === 'won') {
                payoutDisplay = `+$${bet.payout.toFixed(2)}`;
                payoutClass = 'positive';
            } else if (bet.result === 'lost') {
                payoutDisplay = `-$${Math.abs(bet.payout).toFixed(2)}`;
                payoutClass = 'negative';
            } else if (bet.result === 'push') {
                payoutDisplay = '$0.00';
                payoutClass = 'neutral';
            } else {
                payoutDisplay = 'Pending';
                payoutClass = 'pending';
            }

            // Format date
            const date = new Date(bet.timestamp);
            const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

            // Quick result buttons for pending bets (Part 3)
            const quickResultButtons = bet.result === 'pending' ? `
                <div class="quick-result-buttons">
                    <button class="result-btn won" onclick="quickResult('${bet.id}', 'won')" title="Mark as Won">W</button>
                    <button class="result-btn lost" onclick="quickResult('${bet.id}', 'lost')" title="Mark as Lost">L</button>
                    <button class="result-btn push" onclick="quickResult('${bet.id}', 'push')" title="Mark as Push">P</button>
                    <button class="result-btn void" onclick="quickResult('${bet.id}', 'void')" title="Void bet">V</button>
                </div>
            ` : '';

            return `
                <div class="bet-card" data-id="${bet.id}">
                    <div class="bet-card-status ${resultClass}"></div>
                    <div class="bet-card-header">
                        <div class="bet-card-title">
                            <div class="player-name">${escapeHtml(bet.selection)}</div>
                            <div class="bet-type">${formatBetType(bet.bet_type)} @ ${bet.line}</div>
                        </div>
                        <div class="bet-card-badges">
                            <span class="badge ${tierClass}">${bet.tier}</span>
                            <span class="badge badge-week">Wk ${bet.week}</span>
                        </div>
                    </div>
                    <div class="bet-card-body">
                        <div class="bet-details">
                            <div class="bet-detail">
                                <span class="label">Odds</span>
                                <span class="value">${formatOdds(bet.odds)}</span>
                            </div>
                            <div class="bet-detail">
                                <span class="label">Stake</span>
                                <span class="value">$${bet.actual_stake.toFixed(2)}</span>
                            </div>
                            <div class="bet-detail">
                                <span class="label">Model Prob</span>
                                <span class="value highlight">${bet.model_prob?.toFixed(1) || '-'}%</span>
                            </div>
                            <div class="bet-detail">
                                <span class="label">EV</span>
                                <span class="value ${bet.ev_pct > 0 ? 'highlight' : ''}">${bet.ev_pct?.toFixed(1) || '-'}%</span>
                            </div>
                            <div class="bet-detail">
                                <span class="label">Game</span>
                                <span class="value">${escapeHtml(bet.game) || '-'}</span>
                            </div>
                            <div class="bet-detail">
                                <span class="label">Date</span>
                                <span class="value">${dateStr}</span>
                            </div>
                        </div>
                        ${quickResultButtons}
                    </div>
                    <div class="bet-card-footer">
                        <div class="bet-result ${payoutClass}">${payoutDisplay}</div>
                        <div class="bet-card-actions">
                            <button class="btn btn-secondary btn-small" onclick="editBet('${bet.id}')">Edit</button>
                            <button class="btn btn-danger btn-small" onclick="confirmDelete('${bet.id}')">Delete</button>
                        </div>
                    </div>
                </div>
            `;
        }

        /**
         * Format bet type for display
         */
        function formatBetType(type) {
            const types = {
                'player_receptions': 'Receptions',
                'player_reception_yds': 'Rec Yards',
                'player_rush_yds': 'Rush Yards',
                'player_rush_attempts': 'Rush Att',
                'player_pass_yds': 'Pass Yards',
                'player_pass_tds': 'Pass TDs',
                'other': 'Other'
            };
            return types[type] || type;
        }

        /**
         * Format American odds with + prefix for positive
         */
        function formatOdds(odds) {
            return odds > 0 ? `+${odds}` : odds.toString();
        }

        /**
         * Escape HTML to prevent XSS
         */
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Calculate and update summary statistics
         */
        async function updateSummaryStats(bets) {
            const settled = bets.filter(b => b.result !== 'pending');
            const pending = bets.filter(b => b.result === 'pending');

            // Calculate totals
            const totalWagered = settled.reduce((sum, b) => sum + b.actual_stake, 0);
            const totalPL = settled.reduce((sum, b) => sum + b.payout, 0);
            const wins = settled.filter(b => b.result === 'won').length;
            const losses = settled.filter(b => b.result === 'lost').length;
            const pushes = settled.filter(b => b.result === 'push').length;

            // ROI
            const roi = totalWagered > 0 ? (totalPL / totalWagered * 100) : 0;

            // Win rate
            const totalDecided = wins + losses;
            const winRate = totalDecided > 0 ? (wins / totalDecided * 100) : 0;

            // Average CLV (for bets with closing line)
            const betsWithCLV = settled.filter(b => b.closing_line !== null && b.closing_line !== undefined);
            const avgCLV = betsWithCLV.length > 0
                ? betsWithCLV.reduce((sum, b) => sum + (b.line - b.closing_line), 0) / betsWithCLV.length
                : 0;

            // Average EV
            const betsWithEV = bets.filter(b => b.ev_pct !== null && b.ev_pct !== undefined);
            const avgEV = betsWithEV.length > 0
                ? betsWithEV.reduce((sum, b) => sum + b.ev_pct, 0) / betsWithEV.length
                : 0;

            // Pending risk
            const pendingRisk = pending.reduce((sum, b) => sum + b.actual_stake, 0);

            // Update DOM
            const plEl = document.getElementById('stat-total-pl');
            plEl.textContent = `${totalPL >= 0 ? '+' : ''}$${totalPL.toFixed(2)}`;
            plEl.className = `value ${totalPL > 0 ? 'positive' : totalPL < 0 ? 'negative' : 'neutral'}`;
            document.getElementById('stat-total-wagered').textContent = `$${totalWagered.toFixed(2)} wagered`;

            const roiEl = document.getElementById('stat-roi');
            roiEl.textContent = `${roi >= 0 ? '+' : ''}${roi.toFixed(1)}%`;
            roiEl.className = `value ${roi > 0 ? 'positive' : roi < 0 ? 'negative' : 'neutral'}`;

            document.getElementById('stat-record').textContent = `${wins}-${losses}-${pushes}`;
            document.getElementById('stat-win-rate').textContent = `${winRate.toFixed(0)}% win rate`;

            const clvEl = document.getElementById('stat-clv');
            clvEl.textContent = `${avgCLV >= 0 ? '+' : ''}${avgCLV.toFixed(1)}`;
            clvEl.className = `value ${avgCLV > 0 ? 'positive' : avgCLV < 0 ? 'negative' : 'neutral'}`;

            document.getElementById('stat-pending').textContent = pending.length;
            document.getElementById('stat-pending-risk').textContent = `$${pendingRisk.toFixed(2)} at risk`;

            const evEl = document.getElementById('stat-avg-ev');
            evEl.textContent = `${avgEV >= 0 ? '+' : ''}${avgEV.toFixed(1)}%`;
            evEl.className = `value ${avgEV > 0 ? 'positive' : 'neutral'}`;
        }

        /**
         * Update week filter buttons based on available weeks
         */
        function updateWeekFilters(bets) {
            const weeks = [...new Set(bets.map(b => b.week))].sort((a, b) => b - a);
            const container = document.getElementById('week-filters');

            // Keep "All Weeks" button
            container.innerHTML = '<button class="filter-btn active" data-week="all">All Weeks</button>';

            // Add week buttons
            weeks.forEach(week => {
                const btn = document.createElement('button');
                btn.className = 'filter-btn';
                btn.dataset.week = week;
                btn.textContent = `Week ${week}`;
                container.appendChild(btn);
            });

            // Rebind click handlers
            bindFilterHandlers();
        }

        /**
         * Filter bets based on current filters
         */
        function filterBets(bets) {
            return bets.filter(bet => {
                if (currentFilters.result !== 'all' && bet.result !== currentFilters.result) return false;
                if (currentFilters.tier !== 'all' && bet.tier !== currentFilters.tier) return false;
                if (currentFilters.week !== 'all' && bet.week !== parseInt(currentFilters.week)) return false;
                if (currentFilters.type !== 'all' && bet.bet_type !== currentFilters.type) return false;
                return true;
            });
        }

        /**
         * Render bets to a container
         */
        function renderBets(bets, containerId, emptyId) {
            const container = document.getElementById(containerId);
            const emptyState = document.getElementById(emptyId);

            if (bets.length === 0) {
                container.innerHTML = '';
                emptyState.style.display = 'block';
            } else {
                container.innerHTML = bets.map(renderBetCard).join('');
                emptyState.style.display = 'none';
            }
        }

        /**
         * Refresh all UI elements
         */
        async function refreshUI() {
            const allBets = await getAllBets();

            // Update summary stats
            await updateSummaryStats(allBets);

            // Update week filters
            updateWeekFilters(allBets);

            // Dashboard - all filtered bets
            const filteredBets = filterBets(allBets);
            renderBets(filteredBets, 'dashboard-bets', 'dashboard-empty');

            // Active bets
            const activeBets = allBets.filter(b => b.result === 'pending');
            renderBets(activeBets, 'active-bets', 'active-empty');

            // History - settled bets
            const historyBets = allBets.filter(b => b.result !== 'pending');
            renderBets(historyBets, 'history-bets', 'history-empty');

            // Render analytics dashboard (Part 2)
            await renderAnalytics();
        }

        /* ============================================
           MODAL & FORM HANDLING
           ============================================ */

        let editingBetId = null;

        /**
         * Open modal to add new bet
         */
        function openAddBetModal() {
            editingBetId = null;
            document.getElementById('modal-title').textContent = 'Add New Bet';
            document.getElementById('bet-form').reset();
            document.getElementById('bet-id').value = '';
            document.getElementById('result-fields').style.display = 'none';
            document.getElementById('bet-modal').classList.add('active');
        }

        /**
         * Open modal to edit existing bet
         */
        async function editBet(id) {
            const bet = await getBet(id);
            if (!bet) {
                showToast('Bet not found', 'error');
                return;
            }

            editingBetId = id;
            document.getElementById('modal-title').textContent = 'Edit Bet';
            document.getElementById('result-fields').style.display = 'flex';

            // Populate form
            document.getElementById('bet-id').value = bet.id;
            document.getElementById('bet-week').value = bet.week;
            document.getElementById('bet-game').value = bet.game || '';
            document.getElementById('bet-selection').value = bet.selection;
            document.getElementById('bet-type').value = bet.bet_type;
            document.getElementById('bet-line').value = bet.line;
            document.getElementById('bet-odds').value = bet.odds;
            document.getElementById('bet-implied-prob').value = bet.implied_prob?.toFixed(1) || '';
            document.getElementById('bet-model-prob').value = bet.model_prob?.toFixed(1) || '';
            document.getElementById('bet-ev').value = bet.ev_pct?.toFixed(1) || '';
            document.getElementById('bet-tier').value = bet.tier;
            document.getElementById('bet-kelly').value = bet.kelly_suggested?.toFixed(2) || '';
            document.getElementById('bet-stake').value = bet.actual_stake;
            document.getElementById('bet-result').value = bet.result;
            document.getElementById('bet-closing-line').value = bet.closing_line || '';
            document.getElementById('bet-notes').value = bet.notes || '';

            document.getElementById('bet-modal').classList.add('active');
        }

        /**
         * Close the modal
         */
        function closeModal() {
            document.getElementById('bet-modal').classList.remove('active');
            editingBetId = null;
        }

        /**
         * Save bet from form
         */
        async function saveBet() {
            const form = document.getElementById('bet-form');

            // Validate required fields
            if (!form.checkValidity()) {
                form.reportValidity();
                return;
            }

            const betData = {
                week: parseInt(document.getElementById('bet-week').value),
                game: document.getElementById('bet-game').value.trim(),
                selection: document.getElementById('bet-selection').value.trim(),
                bet_type: document.getElementById('bet-type').value,
                line: parseFloat(document.getElementById('bet-line').value),
                odds: parseInt(document.getElementById('bet-odds').value),
                implied_prob: parseFloat(document.getElementById('bet-implied-prob').value) || null,
                model_prob: parseFloat(document.getElementById('bet-model-prob').value) || null,
                ev_pct: parseFloat(document.getElementById('bet-ev').value) || null,
                tier: document.getElementById('bet-tier').value,
                kelly_suggested: parseFloat(document.getElementById('bet-kelly').value) || null,
                actual_stake: parseFloat(document.getElementById('bet-stake').value),
                notes: document.getElementById('bet-notes').value.trim()
            };

            // Calculate implied prob if not provided
            if (!betData.implied_prob) {
                betData.implied_prob = oddsToImpliedProb(betData.odds);
            }

            try {
                if (editingBetId) {
                    // Update existing bet
                    const existingBet = await getBet(editingBetId);
                    const updatedBet = {
                        ...existingBet,
                        ...betData,
                        result: document.getElementById('bet-result').value,
                        closing_line: parseFloat(document.getElementById('bet-closing-line').value) || null
                    };
                    await updateBet(updatedBet);
                    showToast('Bet updated successfully', 'success');
                } else {
                    // Add new bet
                    await addBet(betData);
                    showToast('Bet added successfully', 'success');
                }

                closeModal();
                await refreshUI();

            } catch (e) {
                console.error('Error saving bet:', e);
                showToast('Error saving bet', 'error');
            }
        }

        /**
         * Confirm and delete a bet
         */
        async function confirmDelete(id) {
            if (confirm('Are you sure you want to delete this bet?')) {
                try {
                    await deleteBet(id);
                    showToast('Bet deleted', 'success');
                    await refreshUI();
                } catch (e) {
                    showToast('Error deleting bet', 'error');
                }
            }
        }

        /* ============================================
           TAB NAVIGATION
           ============================================ */

        function initTabs() {
            const tabBtns = document.querySelectorAll('.tab-btn');
            const tabContents = document.querySelectorAll('.tab-content');

            tabBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const tabId = btn.dataset.tab;

                    // Update button states
                    tabBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Update content visibility
                    tabContents.forEach(content => {
                        content.classList.remove('active');
                        if (content.id === `tab-${tabId}`) {
                            content.classList.add('active');
                        }
                    });
                });
            });
        }

        /* ============================================
           FILTER HANDLING
           ============================================ */

        function bindFilterHandlers() {
            // Result filters
            document.querySelectorAll('[data-filter]').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const filterGroup = e.target.closest('.filter-buttons');
                    filterGroup.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentFilters.result = e.target.dataset.filter;
                    await refreshUI();
                });
            });

            // Tier filters
            document.querySelectorAll('[data-tier]').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const filterGroup = e.target.closest('.filter-buttons');
                    filterGroup.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentFilters.tier = e.target.dataset.tier;
                    await refreshUI();
                });
            });

            // Week filters
            document.querySelectorAll('[data-week]').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const filterGroup = e.target.closest('.filter-buttons');
                    filterGroup.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentFilters.week = e.target.dataset.week;
                    await refreshUI();
                });
            });

            // Type filters
            document.querySelectorAll('[data-type]').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const filterGroup = e.target.closest('.filter-buttons');
                    filterGroup.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentFilters.type = e.target.dataset.type;
                    await refreshUI();
                });
            });
        }

        /* ============================================
           TOAST NOTIFICATIONS
           ============================================ */

        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <span>${escapeHtml(message)}</span>
            `;
            container.appendChild(toast);

            // Auto-remove after 3 seconds
            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        /* ============================================
           ANALYTICS FUNCTIONS (Part 2)
           ============================================ */

        /**
         * Calculate ROI for a set of bets with optional filter
         * @param {Array} bets - Array of bet objects
         * @param {Function} filterFn - Optional filter function
         * @returns {Object} - { roi, totalWagered, totalPL, count }
         */
        function calcROI(bets, filterFn = null) {
            let filtered = bets.filter(b => b.result !== 'pending');
            if (filterFn) {
                filtered = filtered.filter(filterFn);
            }

            const totalWagered = filtered.reduce((sum, b) => sum + b.actual_stake, 0);
            const totalPL = filtered.reduce((sum, b) => sum + b.payout, 0);
            const roi = totalWagered > 0 ? (totalPL / totalWagered * 100) : 0;

            return {
                roi,
                totalWagered,
                totalPL,
                count: filtered.length,
                wins: filtered.filter(b => b.result === 'won').length,
                losses: filtered.filter(b => b.result === 'lost').length,
                pushes: filtered.filter(b => b.result === 'push').length
            };
        }

        /**
         * Calculate ROI breakdown by tier
         * @param {Array} bets - Array of bet objects
         * @returns {Object} - { premium: {...}, standard: {...}, value: {...} }
         */
        function calcROIByTier(bets) {
            const tiers = ['premium', 'standard', 'value'];
            const result = {};

            tiers.forEach(tier => {
                result[tier] = calcROI(bets, b => b.tier === tier);
            });

            return result;
        }

        /**
         * Calculate ROI breakdown by bet type (market)
         * @param {Array} bets - Array of bet objects
         * @returns {Object} - { player_receptions: {...}, player_rush_yds: {...}, ... }
         */
        function calcROIByType(bets) {
            // Get unique bet types
            const types = [...new Set(bets.map(b => b.bet_type))];
            const result = {};

            types.forEach(type => {
                result[type] = calcROI(bets, b => b.bet_type === type);
            });

            return result;
        }

        /**
         * Calculate Closing Line Value metrics
         * For UNDER bets: CLV positive if closing line < opening line (line moved down)
         * @param {Array} bets - Array of bet objects
         * @returns {Object} - { avgCLV, beatRate, betsWithCLV }
         */
        function calcCLV(bets) {
            // Only settled bets with closing line data
            const betsWithCLV = bets.filter(b =>
                b.result !== 'pending' &&
                b.closing_line !== null &&
                b.closing_line !== undefined
            );

            if (betsWithCLV.length === 0) {
                return { avgCLV: 0, beatRate: 0, betsWithCLV: 0, totalBets: bets.filter(b => b.result !== 'pending').length };
            }

            // For UNDER bets, we beat CLV if closing line moved down (we got a better number)
            // CLV = opening line - closing line (positive means line moved in our favor)
            const clvValues = betsWithCLV.map(b => b.line - b.closing_line);
            const avgCLV = clvValues.reduce((sum, v) => sum + v, 0) / clvValues.length;

            // Beat rate: % of bets where we got CLV (line moved in our favor)
            const beatCount = clvValues.filter(v => v > 0).length;
            const beatRate = (beatCount / betsWithCLV.length) * 100;

            return {
                avgCLV,
                beatRate,
                betsWithCLV: betsWithCLV.length,
                totalBets: bets.filter(b => b.result !== 'pending').length
            };
        }

        /**
         * Calculate Brier Score for model calibration
         * Brier Score = mean((forecast - outcome)^2)
         * Lower is better. Random guessing = 0.25, perfect = 0
         * @param {Array} bets - Array of bet objects
         * @returns {Object} - { brierScore, skillScore, count }
         */
        function calcBrierScore(bets) {
            // Only settled bets with model probability
            const validBets = bets.filter(b =>
                b.result !== 'pending' &&
                b.result !== 'push' &&
                b.model_prob !== null &&
                b.model_prob !== undefined
            );

            if (validBets.length === 0) {
                return { brierScore: 0, skillScore: 0, count: 0 };
            }

            // For each bet, calculate (forecast - outcome)^2
            // forecast = model_prob / 100 (convert to 0-1)
            // outcome = 1 if won, 0 if lost
            const squaredErrors = validBets.map(b => {
                const forecast = b.model_prob / 100;
                const outcome = b.result === 'won' ? 1 : 0;
                return Math.pow(forecast - outcome, 2);
            });

            const brierScore = squaredErrors.reduce((sum, e) => sum + e, 0) / squaredErrors.length;

            // Skill score: improvement over random guessing (0.25)
            // skillScore = 1 - (brierScore / 0.25)
            // Positive = better than random, negative = worse
            const skillScore = 1 - (brierScore / 0.25);

            return {
                brierScore,
                skillScore,
                count: validBets.length
            };
        }

        /**
         * Calculate Expected vs Actual win rates by confidence tier
         * Groups bets into probability buckets and compares expected vs actual
         * @param {Array} bets - Array of bet objects
         * @returns {Array} - [{ bucket, expected, actual, count }, ...]
         */
        function calcExpectedVsActual(bets) {
            // Only settled bets with model probability
            const validBets = bets.filter(b =>
                b.result !== 'pending' &&
                b.result !== 'push' &&
                b.model_prob !== null &&
                b.model_prob !== undefined
            );

            // Define probability buckets
            const buckets = [
                { label: '50-55%', min: 50, max: 55 },
                { label: '55-60%', min: 55, max: 60 },
                { label: '60-65%', min: 60, max: 65 },
                { label: '65-70%', min: 65, max: 70 },
                { label: '70%+', min: 70, max: 100 }
            ];

            return buckets.map(bucket => {
                const bucketBets = validBets.filter(b =>
                    b.model_prob >= bucket.min && b.model_prob < bucket.max
                );

                if (bucketBets.length === 0) {
                    return {
                        label: bucket.label,
                        expected: (bucket.min + bucket.max) / 2,
                        actual: 0,
                        count: 0
                    };
                }

                // Expected = average model probability in bucket
                const expected = bucketBets.reduce((sum, b) => sum + b.model_prob, 0) / bucketBets.length;

                // Actual = win rate
                const wins = bucketBets.filter(b => b.result === 'won').length;
                const actual = (wins / bucketBets.length) * 100;

                return {
                    label: bucket.label,
                    expected,
                    actual,
                    count: bucketBets.length
                };
            });
        }

        /**
         * Calculate Kelly Criterion adherence
         * Compares actual stakes to Kelly-suggested stakes
         * @param {Array} bets - Array of bet objects
         * @returns {Object} - { avgAdherence, underBet, optimal, overBet, distribution }
         */
        function kellyAdherence(bets) {
            // Only bets with both actual stake and kelly suggested
            const validBets = bets.filter(b =>
                b.kelly_suggested !== null &&
                b.kelly_suggested !== undefined &&
                b.kelly_suggested > 0
            );

            if (validBets.length === 0) {
                return {
                    avgAdherence: 0,
                    underBet: 0,
                    optimal: 0,
                    overBet: 0,
                    distribution: []
                };
            }

            // Calculate adherence ratio for each bet
            // adherence = actual / kelly_suggested
            const adherenceRatios = validBets.map(b => ({
                ratio: b.actual_stake / b.kelly_suggested,
                bet: b
            }));

            const avgAdherence = adherenceRatios.reduce((sum, r) => sum + r.ratio, 0) / adherenceRatios.length * 100;

            // Categorize: under-bet (<80%), optimal (80-120%), over-bet (>120%)
            const underBet = adherenceRatios.filter(r => r.ratio < 0.8).length;
            const optimal = adherenceRatios.filter(r => r.ratio >= 0.8 && r.ratio <= 1.2).length;
            const overBet = adherenceRatios.filter(r => r.ratio > 1.2).length;

            return {
                avgAdherence,
                underBet,
                optimal,
                overBet,
                underBetPct: (underBet / validBets.length) * 100,
                optimalPct: (optimal / validBets.length) * 100,
                overBetPct: (overBet / validBets.length) * 100,
                totalBets: validBets.length
            };
        }

        /**
         * Calculate weekly breakdown statistics
         * @param {Array} bets - Array of bet objects
         * @returns {Array} - Array of weekly stats objects
         */
        function calcWeeklyBreakdown(bets) {
            const weeks = [...new Set(bets.map(b => b.week))].sort((a, b) => a - b);

            return weeks.map(week => {
                const weekBets = bets.filter(b => b.week === week);
                const settled = weekBets.filter(b => b.result !== 'pending');
                const roi = calcROI(weekBets);
                const clv = calcCLV(weekBets);

                // Average EV for the week
                const betsWithEV = weekBets.filter(b => b.ev_pct !== null && b.ev_pct !== undefined);
                const avgEV = betsWithEV.length > 0
                    ? betsWithEV.reduce((sum, b) => sum + b.ev_pct, 0) / betsWithEV.length
                    : 0;

                return {
                    week,
                    totalBets: weekBets.length,
                    settledBets: settled.length,
                    wins: roi.wins,
                    losses: roi.losses,
                    pushes: roi.pushes,
                    winRate: (roi.wins + roi.losses) > 0 ? (roi.wins / (roi.wins + roi.losses) * 100) : 0,
                    wagered: roi.totalWagered,
                    pl: roi.totalPL,
                    roi: roi.roi,
                    avgEV,
                    clvBeatRate: clv.beatRate
                };
            });
        }

        /**
         * Calculate monthly breakdown statistics
         * @param {Array} bets - Array of bet objects
         * @returns {Array} - Array of monthly stats objects
         */
        function calcMonthlyBreakdown(bets) {
            // Group by month
            const monthGroups = {};

            bets.forEach(bet => {
                const date = new Date(bet.timestamp);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthGroups[monthKey]) {
                    monthGroups[monthKey] = [];
                }
                monthGroups[monthKey].push(bet);
            });

            // Calculate stats for each month
            return Object.entries(monthGroups)
                .sort(([a], [b]) => a.localeCompare(b))
                .map(([monthKey, monthBets]) => {
                    const roi = calcROI(monthBets);
                    const [year, month] = monthKey.split('-');
                    const monthName = new Date(year, parseInt(month) - 1).toLocaleString('default', { month: 'short', year: 'numeric' });

                    return {
                        month: monthName,
                        monthKey,
                        totalBets: monthBets.length,
                        wins: roi.wins,
                        losses: roi.losses,
                        pushes: roi.pushes,
                        winRate: (roi.wins + roi.losses) > 0 ? (roi.wins / (roi.wins + roi.losses) * 100) : 0,
                        wagered: roi.totalWagered,
                        pl: roi.totalPL,
                        roi: roi.roi
                    };
                });
        }

        /* ============================================
           ANALYTICS RENDERING FUNCTIONS
           ============================================ */

        /**
         * Render the full analytics dashboard
         */
        async function renderAnalytics() {
            const bets = await getAllBets();
            const settledBets = bets.filter(b => b.result !== 'pending');

            // Show empty state if no settled bets
            const emptyState = document.getElementById('analytics-empty');
            const metricsSection = document.getElementById('analytics-metrics');

            if (settledBets.length === 0) {
                emptyState.style.display = 'block';
                document.getElementById('bankroll-chart-section').style.display = 'none';
                return;
            }
            emptyState.style.display = 'none';

            // Calculate all metrics
            const overallROI = calcROI(bets);
            const roiByTier = calcROIByTier(bets);
            const roiByType = calcROIByType(bets);
            const clvMetrics = calcCLV(bets);
            const brierMetrics = calcBrierScore(bets);
            const expectedVsActual = calcExpectedVsActual(bets);
            const kellyMetrics = kellyAdherence(bets);
            const weeklyBreakdown = calcWeeklyBreakdown(bets);
            const monthlyBreakdown = calcMonthlyBreakdown(bets);

            // Render bankroll chart (Part 3)
            const bankrollData = calculateBankrollData(bets);
            renderBankrollChart(bankrollData);

            // Render each section
            renderROICard(overallROI, weeklyBreakdown);
            renderCLVCard(clvMetrics);
            renderBrierCard(brierMetrics);
            renderKellyCard(kellyMetrics);
            renderTierROI(roiByTier);
            renderExpectedVsActual(expectedVsActual);
            renderTypeROI(roiByType);
            renderWeeklyTable(weeklyBreakdown, overallROI);
            renderMonthlyTable(monthlyBreakdown);
        }

        /**
         * Render Overall ROI card with sparkline
         */
        function renderROICard(roi, weeklyData) {
            const roiEl = document.getElementById('analytics-roi');
            const subtitleEl = document.getElementById('analytics-roi-subtitle');
            const sparklineEl = document.getElementById('roi-sparkline');

            roiEl.textContent = `${roi.roi >= 0 ? '+' : ''}${roi.roi.toFixed(1)}%`;
            roiEl.className = `analytics-card-value ${roi.roi > 0 ? 'positive' : roi.roi < 0 ? 'negative' : 'neutral'}`;
            subtitleEl.textContent = `${roi.count} settled bets | $${roi.totalWagered.toFixed(0)} wagered`;

            // Render sparkline from weekly P/L
            if (weeklyData.length > 0) {
                const plValues = weeklyData.map(w => w.pl);
                const maxAbsPL = Math.max(...plValues.map(Math.abs), 1);

                sparklineEl.innerHTML = plValues.map(pl => {
                    const height = Math.abs(pl) / maxAbsPL * 100;
                    const color = pl >= 0 ? 'var(--status-won)' : 'var(--status-lost)';
                    return `<div class="sparkline-bar" style="height: ${Math.max(height, 5)}%; background: ${color};"></div>`;
                }).join('');
            }
        }

        /**
         * Render CLV card with gauge
         */
        function renderCLVCard(clv) {
            const clvEl = document.getElementById('analytics-clv');
            const subtitleEl = document.getElementById('analytics-clv-subtitle');
            const needleEl = document.getElementById('clv-needle');
            const gaugeValueEl = document.getElementById('clv-gauge-value');

            clvEl.textContent = `${clv.avgCLV >= 0 ? '+' : ''}${clv.avgCLV.toFixed(2)}`;
            clvEl.className = `analytics-card-value ${clv.avgCLV > 0 ? 'positive' : clv.avgCLV < 0 ? 'negative' : 'neutral'}`;
            subtitleEl.textContent = `${clv.beatRate.toFixed(0)}% beat closing line (${clv.betsWithCLV}/${clv.totalBets} tracked)`;

            // Rotate needle based on beat rate (0% = -90deg, 100% = 90deg)
            const rotation = (clv.beatRate / 100) * 180 - 90;
            needleEl.style.transform = `rotate(${rotation}deg)`;
            gaugeValueEl.textContent = `${clv.beatRate.toFixed(0)}%`;
        }

        /**
         * Render Brier Score card
         */
        function renderBrierCard(brier) {
            const brierEl = document.getElementById('analytics-brier');
            const vsRandomEl = document.getElementById('brier-vs-random');
            const barEl = document.getElementById('brier-bar');

            brierEl.textContent = brier.brierScore.toFixed(3);
            brierEl.className = `analytics-card-value ${brier.skillScore > 0 ? 'positive' : brier.skillScore < 0 ? 'negative' : 'neutral'}`;

            // Show skill score comparison
            const skillPct = (brier.skillScore * 100).toFixed(1);
            vsRandomEl.textContent = brier.skillScore >= 0 ? `${skillPct}% better` : `${Math.abs(skillPct)}% worse`;
            vsRandomEl.className = brier.skillScore >= 0 ? 'positive' : 'negative';

            // Bar shows Brier score relative to 0.25 (lower is better)
            const barWidth = Math.min(100, (1 - brier.brierScore / 0.5) * 100);
            barEl.style.width = `${barWidth}%`;
            barEl.className = `bar-chart-fill ${brier.skillScore > 0 ? 'positive' : 'negative'}`;
        }

        /**
         * Render Kelly Adherence card
         */
        function renderKellyCard(kelly) {
            const kellyEl = document.getElementById('analytics-kelly');
            const subtitleEl = document.getElementById('analytics-kelly-subtitle');
            const distributionEl = document.getElementById('kelly-distribution');

            kellyEl.textContent = `${kelly.avgAdherence.toFixed(0)}%`;

            // Color based on adherence (80-120% is optimal)
            let adherenceClass = 'neutral';
            if (kelly.avgAdherence >= 80 && kelly.avgAdherence <= 120) {
                adherenceClass = 'positive';
            } else if (kelly.avgAdherence < 50 || kelly.avgAdherence > 150) {
                adherenceClass = 'warning';
            }
            kellyEl.className = `analytics-card-value ${adherenceClass}`;

            subtitleEl.textContent = `${kelly.totalBets} bets with Kelly data`;

            // Render distribution bars
            distributionEl.innerHTML = `
                <div class="bar-chart-item">
                    <div class="bar-chart-label">
                        <span class="bar-chart-label-text">Under-bet (&lt;80%)</span>
                        <span class="bar-chart-label-value">${kelly.underBet} (${kelly.underBetPct?.toFixed(0) || 0}%)</span>
                    </div>
                    <div class="bar-chart-track">
                        <div class="bar-chart-fill positive" style="width: ${kelly.underBetPct || 0}%;"></div>
                    </div>
                </div>
                <div class="bar-chart-item">
                    <div class="bar-chart-label">
                        <span class="bar-chart-label-text">Optimal (80-120%)</span>
                        <span class="bar-chart-label-value">${kelly.optimal} (${kelly.optimalPct?.toFixed(0) || 0}%)</span>
                    </div>
                    <div class="bar-chart-track">
                        <div class="bar-chart-fill neutral" style="width: ${kelly.optimalPct || 0}%;"></div>
                    </div>
                </div>
                <div class="bar-chart-item">
                    <div class="bar-chart-label">
                        <span class="bar-chart-label-text">Over-bet (&gt;120%)</span>
                        <span class="bar-chart-label-value">${kelly.overBet} (${kelly.overBetPct?.toFixed(0) || 0}%)</span>
                    </div>
                    <div class="bar-chart-track">
                        <div class="bar-chart-fill negative" style="width: ${kelly.overBetPct || 0}%;"></div>
                    </div>
                </div>
            `;
        }

        /**
         * Render ROI by Tier comparison bars
         */
        function renderTierROI(tierROI) {
            const container = document.getElementById('tier-roi-bars');
            const tiers = [
                { key: 'premium', label: 'Premium', color: 'var(--tier-premium)' },
                { key: 'standard', label: 'Standard', color: 'var(--tier-standard)' },
                { key: 'value', label: 'Value', color: 'var(--tier-value)' }
            ];

            // Find max ROI for scaling
            const maxROI = Math.max(...Object.values(tierROI).map(t => Math.abs(t.roi)), 10);

            container.innerHTML = tiers.map(tier => {
                const data = tierROI[tier.key];
                const barWidth = Math.abs(data.roi) / maxROI * 100;
                const record = `${data.wins}-${data.losses}${data.pushes > 0 ? `-${data.pushes}` : ''}`;

                return `
                    <div class="comparison-bar-row">
                        <span class="comparison-bar-label">${tier.label}</span>
                        <div class="comparison-bar-container">
                            <div class="comparison-bar" style="width: ${barWidth}%; background: ${data.roi >= 0 ? 'var(--status-won)' : 'var(--status-lost)'};">
                                ${record}
                            </div>
                        </div>
                        <span class="comparison-bar-value ${data.roi >= 0 ? 'positive' : 'negative'}">
                            ${data.roi >= 0 ? '+' : ''}${data.roi.toFixed(1)}%
                        </span>
                    </div>
                `;
            }).join('');
        }

        /**
         * Render Expected vs Actual calibration chart
         */
        function renderExpectedVsActual(data) {
            const container = document.getElementById('tier-calibration');

            container.innerHTML = data.map(bucket => {
                const actualHeight = bucket.count > 0 ? bucket.actual : 0;
                const expectedPosition = 100 - bucket.expected; // Invert for CSS positioning

                // Color based on actual vs expected
                let fillColor = 'var(--accent-blue)';
                if (bucket.count > 0) {
                    if (bucket.actual > bucket.expected) {
                        fillColor = 'var(--status-won)';
                    } else if (bucket.actual < bucket.expected - 10) {
                        fillColor = 'var(--status-lost)';
                    }
                }

                return `
                    <div class="calibration-bucket">
                        <div class="calibration-bucket-bar">
                            <div class="calibration-expected" style="bottom: ${bucket.expected}%;"></div>
                            <div class="calibration-actual" style="height: ${actualHeight}%; background: ${fillColor};"></div>
                        </div>
                        <div class="calibration-bucket-label">${bucket.label}</div>
                        <div class="calibration-bucket-value">${bucket.count > 0 ? bucket.actual.toFixed(0) + '%' : '-'}</div>
                    </div>
                `;
            }).join('');
        }

        /**
         * Render ROI by Market Type comparison bars
         */
        function renderTypeROI(typeROI) {
            const container = document.getElementById('type-roi-bars');

            // Sort by number of bets (most popular first)
            const sortedTypes = Object.entries(typeROI)
                .sort(([, a], [, b]) => b.count - a.count);

            if (sortedTypes.length === 0) {
                container.innerHTML = '<p style="color: var(--text-muted);">No data yet</p>';
                return;
            }

            const maxROI = Math.max(...sortedTypes.map(([, t]) => Math.abs(t.roi)), 10);

            container.innerHTML = sortedTypes.map(([type, data]) => {
                const barWidth = Math.abs(data.roi) / maxROI * 100;
                const record = `${data.wins}-${data.losses}${data.pushes > 0 ? `-${data.pushes}` : ''}`;
                const label = formatBetType(type);

                return `
                    <div class="comparison-bar-row">
                        <span class="comparison-bar-label">${label}</span>
                        <div class="comparison-bar-container">
                            <div class="comparison-bar" style="width: ${barWidth}%; background: ${data.roi >= 0 ? 'var(--status-won)' : 'var(--status-lost)'};">
                                ${record}
                            </div>
                        </div>
                        <span class="comparison-bar-value ${data.roi >= 0 ? 'positive' : 'negative'}">
                            ${data.roi >= 0 ? '+' : ''}${data.roi.toFixed(1)}%
                        </span>
                    </div>
                `;
            }).join('');
        }

        /**
         * Render Weekly Breakdown table
         */
        function renderWeeklyTable(weeklyData, totals) {
            const tbody = document.getElementById('weekly-breakdown-body');
            const tfoot = document.getElementById('weekly-breakdown-footer');

            tbody.innerHTML = weeklyData.map(week => `
                <tr>
                    <td>Week ${week.week}</td>
                    <td>${week.totalBets}</td>
                    <td>${week.wins}-${week.losses}${week.pushes > 0 ? `-${week.pushes}` : ''}</td>
                    <td>${week.winRate.toFixed(0)}%</td>
                    <td>$${week.wagered.toFixed(2)}</td>
                    <td class="${week.pl >= 0 ? 'positive' : 'negative'}">${week.pl >= 0 ? '+' : ''}$${week.pl.toFixed(2)}</td>
                    <td class="${week.roi >= 0 ? 'positive' : 'negative'}">${week.roi >= 0 ? '+' : ''}${week.roi.toFixed(1)}%</td>
                    <td>${week.avgEV > 0 ? '+' : ''}${week.avgEV.toFixed(1)}%</td>
                    <td>${week.clvBeatRate.toFixed(0)}%</td>
                </tr>
            `).join('');

            // Totals footer
            const totalWinRate = (totals.wins + totals.losses) > 0
                ? (totals.wins / (totals.wins + totals.losses) * 100)
                : 0;

            tfoot.innerHTML = `
                <tr style="font-weight: 600; background: rgba(0,0,0,0.2);">
                    <td>TOTAL</td>
                    <td>${totals.count}</td>
                    <td>${totals.wins}-${totals.losses}${totals.pushes > 0 ? `-${totals.pushes}` : ''}</td>
                    <td>${totalWinRate.toFixed(0)}%</td>
                    <td>$${totals.totalWagered.toFixed(2)}</td>
                    <td class="${totals.totalPL >= 0 ? 'positive' : 'negative'}">${totals.totalPL >= 0 ? '+' : ''}$${totals.totalPL.toFixed(2)}</td>
                    <td class="${totals.roi >= 0 ? 'positive' : 'negative'}">${totals.roi >= 0 ? '+' : ''}${totals.roi.toFixed(1)}%</td>
                    <td>-</td>
                    <td>-</td>
                </tr>
            `;
        }

        /**
         * Render Monthly Breakdown table
         */
        function renderMonthlyTable(monthlyData) {
            const section = document.getElementById('monthly-breakdown-section');
            const tbody = document.getElementById('monthly-breakdown-body');

            // Hide if only one month
            if (monthlyData.length <= 1) {
                section.style.display = 'none';
                return;
            }
            section.style.display = 'block';

            tbody.innerHTML = monthlyData.map(month => `
                <tr>
                    <td>${month.month}</td>
                    <td>${month.totalBets}</td>
                    <td>${month.wins}-${month.losses}${month.pushes > 0 ? `-${month.pushes}` : ''}</td>
                    <td>${month.winRate.toFixed(0)}%</td>
                    <td>$${month.wagered.toFixed(2)}</td>
                    <td class="${month.pl >= 0 ? 'positive' : 'negative'}">${month.pl >= 0 ? '+' : ''}$${month.pl.toFixed(2)}</td>
                    <td class="${month.roi >= 0 ? 'positive' : 'negative'}">${month.roi >= 0 ? '+' : ''}${month.roi.toFixed(1)}%</td>
                </tr>
            `).join('');
        }

        /* ============================================
           PART 3: QUICK RESULT ENTRY
           ============================================ */

        /**
         * Quick result entry - mark bet as won/lost/push/void with one click
         * Auto-calculates payout based on result and odds
         * @param {string} betId - The bet ID
         * @param {string} result - 'won', 'lost', 'push', or 'void'
         */
        async function quickResult(betId, result) {
            try {
                const bet = await getBet(betId);
                if (!bet) {
                    showToast('Bet not found', 'error');
                    return;
                }

                // Handle void - delete the bet
                if (result === 'void') {
                    if (confirm('Void this bet? It will be deleted.')) {
                        await deleteBet(betId);
                        showToast('Bet voided', 'info');
                        await refreshUI();
                    }
                    return;
                }

                // Calculate payout based on result
                bet.result = result;
                bet.payout = calculatePayout(bet.actual_stake, bet.odds, result);

                // Prompt for closing line (optional)
                const closingLine = prompt(
                    `Enter closing line (optional, was ${bet.line}):`,
                    bet.line
                );
                if (closingLine !== null && closingLine !== '') {
                    bet.closing_line = parseFloat(closingLine);
                }

                await updateBet(bet);

                const resultText = result === 'won' ? 'Won' : result === 'lost' ? 'Lost' : 'Push';
                const payoutText = bet.payout >= 0 ? `+$${bet.payout.toFixed(2)}` : `-$${Math.abs(bet.payout).toFixed(2)}`;
                showToast(`${resultText}: ${payoutText}`, result === 'won' ? 'success' : 'info');

                await refreshUI();

            } catch (e) {
                console.error('Error updating result:', e);
                showToast('Error updating result', 'error');
            }
        }

        /**
         * Open result entry modal with closing line input
         * @param {string} betId - The bet ID
         */
        async function openResultModal(betId) {
            const bet = await getBet(betId);
            if (!bet) return;

            // Use the edit modal but focus on result fields
            await editBet(betId);
            document.getElementById('result-fields').style.display = 'flex';
            document.getElementById('bet-result').focus();
        }

        /* ============================================
           PART 3: CAPTURE BET FROM CARD
           ============================================ */

        // Store for captured bet data
        let capturedBetData = null;

        /**
         * Capture bet details from a recommendation card element
         * Extracts data attributes or text content from card structure
         * @param {HTMLElement|Object} cardOrData - Card element or bet data object
         * @returns {Object} - Bet data object
         */
        function captureBetFromCard(cardOrData) {
            // If it's already an object, use it directly
            if (typeof cardOrData === 'object' && !cardOrData.tagName) {
                return {
                    week: cardOrData.week || getCurrentWeek(),
                    game: cardOrData.game || '',
                    selection: cardOrData.selection || cardOrData.player || '',
                    bet_type: cardOrData.bet_type || cardOrData.market || 'other',
                    line: parseFloat(cardOrData.line) || 0,
                    odds: parseInt(cardOrData.odds) || -110,
                    implied_prob: parseFloat(cardOrData.implied_prob) || null,
                    model_prob: parseFloat(cardOrData.model_prob) || parseFloat(cardOrData.prob) || null,
                    ev_pct: parseFloat(cardOrData.ev_pct) || parseFloat(cardOrData.ev) || null,
                    tier: cardOrData.tier || 'standard',
                    kelly_suggested: parseFloat(cardOrData.kelly_suggested) || parseFloat(cardOrData.kelly) || null
                };
            }

            // Parse from DOM element
            const card = cardOrData;
            try {
                return {
                    week: parseInt(card.dataset.week) || getCurrentWeek(),
                    game: card.dataset.game || card.querySelector('.game')?.textContent || '',
                    selection: card.dataset.selection || card.querySelector('.player, .selection')?.textContent || '',
                    bet_type: card.dataset.betType || card.dataset.market || 'other',
                    line: parseFloat(card.dataset.line) || 0,
                    odds: parseInt(card.dataset.odds) || -110,
                    implied_prob: parseFloat(card.dataset.impliedProb) || null,
                    model_prob: parseFloat(card.dataset.modelProb) || null,
                    ev_pct: parseFloat(card.dataset.ev) || null,
                    tier: card.dataset.tier || 'standard',
                    kelly_suggested: parseFloat(card.dataset.kelly) || null
                };
            } catch (e) {
                console.error('Error parsing card:', e);
                return null;
            }
        }

        /**
         * Get current NFL week (estimate)
         */
        function getCurrentWeek() {
            // NFL season typically starts first Thursday of September
            // This is a rough estimate - in production, fetch from API
            const now = new Date();
            const seasonStart = new Date(now.getFullYear(), 8, 5); // Sept 5
            if (now < seasonStart) return 1;
            const weeksSinceStart = Math.floor((now - seasonStart) / (7 * 24 * 60 * 60 * 1000));
            return Math.min(Math.max(weeksSinceStart + 1, 1), 18);
        }

        /**
         * Open the Take Bet modal with captured data
         * @param {Object} betData - Captured bet data
         */
        function openTakeBetModal(betData) {
            capturedBetData = betData;

            // Reset form and populate with captured data
            document.getElementById('bet-form').reset();
            document.getElementById('modal-title').textContent = 'Take This Bet';
            document.getElementById('bet-id').value = '';
            document.getElementById('result-fields').style.display = 'none';

            // Populate form fields
            document.getElementById('bet-week').value = betData.week || '';
            document.getElementById('bet-game').value = betData.game || '';
            document.getElementById('bet-selection').value = betData.selection || '';
            document.getElementById('bet-type').value = betData.bet_type || '';
            document.getElementById('bet-line').value = betData.line || '';
            document.getElementById('bet-odds').value = betData.odds || -110;
            document.getElementById('bet-implied-prob').value = betData.implied_prob?.toFixed(1) || '';
            document.getElementById('bet-model-prob').value = betData.model_prob?.toFixed(1) || '';
            document.getElementById('bet-ev').value = betData.ev_pct?.toFixed(1) || '';
            document.getElementById('bet-tier').value = betData.tier || 'standard';
            document.getElementById('bet-kelly').value = betData.kelly_suggested?.toFixed(2) || '';

            // Focus on stake input
            document.getElementById('bet-modal').classList.add('active');
            setTimeout(() => document.getElementById('bet-stake').focus(), 100);
        }

        /**
         * Quick take bet with preset stake amounts
         * @param {Object} betData - Bet data object
         * @param {number} stake - Stake amount
         */
        async function quickTakeBet(betData, stake) {
            const fullBetData = {
                ...captureBetFromCard(betData),
                actual_stake: stake
            };

            try {
                await addBet(fullBetData);
                showToast(`Bet added: $${stake.toFixed(2)} on ${fullBetData.selection}`, 'success');
                await refreshUI();
            } catch (e) {
                console.error('Error adding bet:', e);
                showToast('Error adding bet', 'error');
            }
        }

        /**
         * Calculate potential payout for display
         * @param {number} stake - Stake amount
         * @param {number} odds - American odds
         * @returns {number} - Potential profit
         */
        function calculatePotentialPayout(stake, odds) {
            if (!stake || !odds) return 0;
            if (odds < 0) {
                return stake * (100 / Math.abs(odds));
            } else {
                return stake * (odds / 100);
            }
        }

        /**
         * Update payout preview when stake changes
         */
        function updatePayoutPreview() {
            const stake = parseFloat(document.getElementById('bet-stake').value) || 0;
            const odds = parseInt(document.getElementById('bet-odds').value) || -110;
            const potential = calculatePotentialPayout(stake, odds);

            const previewEl = document.getElementById('payout-preview-value');
            if (previewEl) {
                previewEl.textContent = `+$${potential.toFixed(2)}`;
            }
        }

        /* ============================================
           PART 3: BANKROLL CHART
           ============================================ */

        /**
         * Calculate running bankroll data for chart
         * @param {Array} bets - Array of bet objects
         * @returns {Object} - { actual: [], kelly: [], labels: [] }
         */
        function calculateBankrollData(bets) {
            // Sort bets by timestamp
            const settledBets = bets
                .filter(b => b.result !== 'pending')
                .sort((a, b) => a.timestamp - b.timestamp);

            if (settledBets.length === 0) {
                return { actual: [0], kelly: [0], labels: ['Start'], bets: [] };
            }

            let actualRunning = 0;
            let kellyRunning = 0;

            const actual = [0]; // Start at 0
            const kelly = [0];
            const labels = ['Start'];
            const betDetails = [null];

            settledBets.forEach((bet, index) => {
                // Actual P/L
                actualRunning += bet.payout;
                actual.push(actualRunning);

                // Kelly "what if" P/L
                // Calculate what payout would have been with Kelly stake
                const kellyStake = bet.kelly_suggested || bet.actual_stake;
                const kellyPayout = calculatePayout(kellyStake, bet.odds, bet.result);
                kellyRunning += kellyPayout;
                kelly.push(kellyRunning);

                // Label (use week or date)
                const date = new Date(bet.timestamp);
                labels.push(`Wk${bet.week}`);
                betDetails.push({
                    selection: bet.selection,
                    result: bet.result,
                    actualPayout: bet.payout,
                    kellyPayout: kellyPayout,
                    date: date.toLocaleDateString()
                });
            });

            return { actual, kelly, labels, bets: betDetails };
        }

        /**
         * Render the bankroll SVG chart
         * @param {Object} data - Chart data from calculateBankrollData
         */
        function renderBankrollChart(data) {
            const svg = document.querySelector('#bankroll-chart svg');
            if (!svg || data.actual.length <= 1) {
                document.getElementById('bankroll-chart-section').style.display = 'none';
                return;
            }
            document.getElementById('bankroll-chart-section').style.display = 'block';

            const width = 800;
            const height = 200;
            const padding = { top: 20, right: 20, bottom: 10, left: 50 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Find min/max for scaling
            const allValues = [...data.actual, ...data.kelly];
            const maxVal = Math.max(...allValues, 10);
            const minVal = Math.min(...allValues, -10);
            const range = Math.max(maxVal - minVal, 20);

            // Scale functions
            const xScale = (i) => padding.left + (i / (data.actual.length - 1)) * chartWidth;
            const yScale = (val) => padding.top + ((maxVal - val) / range) * chartHeight;

            // Zero line position
            const zeroY = yScale(0);
            svg.querySelector('.chart-zero-line').setAttribute('y1', zeroY);
            svg.querySelector('.chart-zero-line').setAttribute('y2', zeroY);
            svg.querySelector('.chart-zero-line').setAttribute('x1', padding.left);
            svg.querySelector('.chart-zero-line').setAttribute('x2', width - padding.right);

            // Build path strings
            const actualPath = data.actual.map((val, i) => {
                const x = xScale(i);
                const y = yScale(val);
                return `${i === 0 ? 'M' : 'L'} ${x} ${y}`;
            }).join(' ');

            const kellyPath = data.kelly.map((val, i) => {
                const x = xScale(i);
                const y = yScale(val);
                return `${i === 0 ? 'M' : 'L'} ${x} ${y}`;
            }).join(' ');

            // Area paths (fill under/over zero line)
            const actualAreaPath = actualPath +
                ` L ${xScale(data.actual.length - 1)} ${zeroY}` +
                ` L ${xScale(0)} ${zeroY} Z`;

            const kellyAreaPath = kellyPath +
                ` L ${xScale(data.kelly.length - 1)} ${zeroY}` +
                ` L ${xScale(0)} ${zeroY} Z`;

            // Update paths
            svg.querySelector('.chart-line.actual').setAttribute('d', actualPath);
            svg.querySelector('.chart-line.kelly').setAttribute('d', kellyPath);
            svg.querySelector('.chart-area.actual').setAttribute('d', actualAreaPath);
            svg.querySelector('.chart-area.kelly').setAttribute('d', kellyAreaPath);

            // Add points
            const actualPointsGroup = svg.querySelector('.chart-points-actual');
            const kellyPointsGroup = svg.querySelector('.chart-points-kelly');
            actualPointsGroup.innerHTML = '';
            kellyPointsGroup.innerHTML = '';

            data.actual.forEach((val, i) => {
                if (i === 0) return; // Skip start point
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', xScale(i));
                circle.setAttribute('cy', yScale(val));
                circle.setAttribute('r', 4);
                circle.setAttribute('class', 'chart-point actual');
                circle.dataset.index = i;
                circle.dataset.type = 'actual';
                actualPointsGroup.appendChild(circle);
            });

            data.kelly.forEach((val, i) => {
                if (i === 0) return;
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', xScale(i));
                circle.setAttribute('cy', yScale(val));
                circle.setAttribute('r', 4);
                circle.setAttribute('class', 'chart-point kelly');
                circle.dataset.index = i;
                circle.dataset.type = 'kelly';
                kellyPointsGroup.appendChild(circle);
            });

            // X-axis labels
            const labelsContainer = document.getElementById('chart-x-labels');
            const labelStep = Math.max(1, Math.floor(data.labels.length / 8));
            labelsContainer.innerHTML = data.labels
                .filter((_, i) => i % labelStep === 0 || i === data.labels.length - 1)
                .map(label => `<span>${label}</span>`)
                .join('');

            // Store data for tooltips
            svg.dataset.chartData = JSON.stringify(data);
        }

        /**
         * Show tooltip on chart point hover
         */
        function setupChartTooltips() {
            const svg = document.querySelector('#bankroll-chart svg');
            const tooltip = document.getElementById('chart-tooltip');

            if (!svg || !tooltip) return;

            svg.addEventListener('mouseover', (e) => {
                if (!e.target.classList.contains('chart-point')) return;

                const index = parseInt(e.target.dataset.index);
                const type = e.target.dataset.type;
                const data = JSON.parse(svg.dataset.chartData || '{}');

                if (!data.bets || !data.bets[index]) return;

                const bet = data.bets[index];
                const value = type === 'actual' ? data.actual[index] : data.kelly[index];

                tooltip.innerHTML = `
                    <div><strong>${bet.selection}</strong></div>
                    <div>${bet.date} - ${bet.result.toUpperCase()}</div>
                    <div>${type === 'actual' ? 'Actual' : 'Kelly'}: ${value >= 0 ? '+' : ''}$${value.toFixed(2)}</div>
                `;

                const rect = e.target.getBoundingClientRect();
                const chartRect = svg.getBoundingClientRect();
                tooltip.style.left = `${rect.left - chartRect.left + 10}px`;
                tooltip.style.top = `${rect.top - chartRect.top - 60}px`;
                tooltip.classList.add('visible');
            });

            svg.addEventListener('mouseout', (e) => {
                if (e.target.classList.contains('chart-point')) {
                    tooltip.classList.remove('visible');
                }
            });
        }

        /* ============================================
           PART 3: INTEGRATION WITH EXTERNAL SYSTEMS
           ============================================ */

        /**
         * Global function to add bet from external source (e.g., dashboard)
         * Can be called from other pages via postMessage or direct function call
         * @param {Object} betData - Bet data from recommendation system
         */
        window.NFLQuantTracker = {
            addBet: async function(betData) {
                const captured = captureBetFromCard(betData);
                openTakeBetModal(captured);
            },

            quickAdd: async function(betData, stake) {
                await quickTakeBet(betData, stake);
            },

            getBets: async function() {
                return await getAllBets();
            },

            getStats: async function() {
                const bets = await getAllBets();
                return {
                    roi: calcROI(bets),
                    clv: calcCLV(bets),
                    brier: calcBrierScore(bets)
                };
            }
        };

        /**
         * Listen for postMessage from parent/external windows
         */
        window.addEventListener('message', async (event) => {
            // Validate origin in production
            if (event.data && event.data.type === 'NFL_QUANT_ADD_BET') {
                window.NFLQuantTracker.addBet(event.data.bet);
            }
        });

        /* ============================================
           SAMPLE DATA FOR TESTING
           ============================================ */

        async function loadSampleData() {
            const sampleBets = [
                {
                    week: 14,
                    game: 'KC @ CLE',
                    selection: 'Travis Kelce UNDER',
                    bet_type: 'player_receptions',
                    line: 5.5,
                    odds: -115,
                    implied_prob: 53.5,
                    model_prob: 68.2,
                    ev_pct: 14.7,
                    tier: 'premium',
                    kelly_suggested: 12.50,
                    actual_stake: 10.00,
                    closing_line: 5.0,
                    result: 'won',
                    payout: 8.70,
                    notes: 'Model strong on this, CLV confirmed edge'
                },
                {
                    week: 14,
                    game: 'BUF @ DET',
                    selection: 'James Cook UNDER',
                    bet_type: 'player_rush_yds',
                    line: 62.5,
                    odds: -110,
                    implied_prob: 52.4,
                    model_prob: 61.5,
                    ev_pct: 9.1,
                    tier: 'standard',
                    kelly_suggested: 8.00,
                    actual_stake: 5.00,
                    closing_line: 60.5,
                    result: 'lost',
                    payout: -5.00,
                    notes: 'Cook popped off, variance happens'
                },
                {
                    week: 14,
                    game: 'LAR @ SF',
                    selection: 'Puka Nacua UNDER',
                    bet_type: 'player_reception_yds',
                    line: 78.5,
                    odds: -105,
                    implied_prob: 51.2,
                    model_prob: 64.8,
                    ev_pct: 13.6,
                    tier: 'premium',
                    kelly_suggested: 15.00,
                    actual_stake: 10.00,
                    closing_line: 75.5,
                    result: 'won',
                    payout: 9.52,
                    notes: 'Strong CLV, defense played well'
                },
                {
                    week: 15,
                    game: 'PHI @ PIT',
                    selection: 'Saquon Barkley UNDER',
                    bet_type: 'player_rush_yds',
                    line: 89.5,
                    odds: -108,
                    implied_prob: 51.9,
                    model_prob: 58.3,
                    ev_pct: 6.4,
                    tier: 'standard',
                    kelly_suggested: 6.00,
                    actual_stake: 5.00,
                    closing_line: null,
                    result: 'pending',
                    payout: 0,
                    notes: 'Steelers run D solid'
                },
                {
                    week: 15,
                    game: 'DEN @ IND',
                    selection: 'Courtland Sutton UNDER',
                    bet_type: 'player_receptions',
                    line: 4.5,
                    odds: -120,
                    implied_prob: 54.5,
                    model_prob: 71.2,
                    ev_pct: 16.7,
                    tier: 'premium',
                    kelly_suggested: 18.00,
                    actual_stake: 10.00,
                    closing_line: null,
                    result: 'pending',
                    payout: 0,
                    notes: 'Strong model confidence, Bo Nix spreading ball around'
                }
            ];

            // Check if we already have data
            const existing = await getAllBets();
            if (existing.length > 0) {
                console.log('Sample data not loaded - bets already exist');
                return;
            }

            // Add sample bets
            for (const bet of sampleBets) {
                await addBet(bet);
            }

            console.log('Sample data loaded');
            showToast('Sample data loaded for testing', 'info');
        }

        /* ============================================
           INITIALIZATION
           ============================================ */

        async function init() {
            try {
                // Initialize IndexedDB
                await initDB();

                // Initialize UI components
                initTabs();
                bindFilterHandlers();

                // Setup chart tooltips (Part 3)
                setupChartTooltips();

                // Setup stake input listener for payout preview
                const stakeInput = document.getElementById('bet-stake');
                const oddsInput = document.getElementById('bet-odds');
                if (stakeInput) {
                    stakeInput.addEventListener('input', updatePayoutPreview);
                }
                if (oddsInput) {
                    oddsInput.addEventListener('input', updatePayoutPreview);
                }

                // Load sample data if empty
                await loadSampleData();

                // Refresh UI
                await refreshUI();

                console.log('NFL QUANT Bet Tracker initialized (v1.0 - Parts 1-3)');

            } catch (e) {
                console.error('Initialization error:', e);
                showToast('Error initializing app', 'error');
            }
        }

        // Start app when DOM is ready
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
