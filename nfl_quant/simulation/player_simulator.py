"""
Player Simulator - Backward Compatible Wrapper for V3

This module maintains the original PlayerSimulator API while using
PlayerSimulatorV3 as the backend. All existing code works without modification.

Auto-generated by migrate_to_v3.py on 2025-11-03 21:20:40
"""

import warnings
import logging
from typing import Dict, List, Optional, Tuple
from pathlib import Path

from nfl_quant.simulation.player_simulator_v3_correlated import PlayerSimulatorV3
from nfl_quant.models.usage_predictor import UsagePredictor
from nfl_quant.models.efficiency_predictor import EfficiencyPredictor
from nfl_quant.calibration.isotonic_calibrator import NFLProbabilityCalibrator
from nfl_quant.config_enhanced import config

logger = logging.getLogger(__name__)


class PlayerSimulator(PlayerSimulatorV3):
    """
    Backward-compatible wrapper around PlayerSimulatorV3.

    Maintains V1 API while using V3 backend with all improvements.
    """

    def __init__(
        self,
        usage_predictor: UsagePredictor,
        efficiency_predictor: EfficiencyPredictor,
        trials: Optional[int] = None,
        seed: Optional[int] = None,
        calibrator: Optional[NFLProbabilityCalibrator] = None,
        td_calibrator: Optional[object] = None,
        **kwargs
    ):
        correlation_config = kwargs.pop('correlation_config', None)

        super().__init__(
            usage_predictor=usage_predictor,
            efficiency_predictor=efficiency_predictor,
            trials=trials,
            seed=seed,
            calibrator=calibrator,
            td_calibrator=td_calibrator,
            correlation_config=correlation_config,
        )

        logger.info("PlayerSimulator initialized with V3 backend (correlation-aware)")

    def simulate_player(self, player_input, game_context=None):
        """
        Backward-compatible wrapper for single-player simulation.

        V1 API: simulate_player(player_input) -> Dict[str, np.ndarray]
        V3 API: simulate_team_players(team_players, game_context) -> Dict[player_id, Dict[str, np.ndarray]]

        This method wraps the V3 API to maintain V1 compatibility.

        Args:
            player_input: PlayerPropInput object
            game_context: Optional game context dict (team pass/rush attempts, pace, etc.)
        """
        # V3 simulate_team_players expects a list of PlayerPropInput objects
        # Just pass single player as a list
        team_players = [player_input]

        # Call V3 simulate_team_players with single player and game context
        results = self.simulate_team_players(team_players, game_context=game_context)

        # Extract single player result
        if player_input.player_id in results:
            return results[player_input.player_id]
        else:
            # If player_id not found, return empty result
            logger.warning(f"Player {player_input.player_id} not found in V3 results")
            return {}


def load_predictors(
    usage_model_path: Optional[str] = None,
    efficiency_model_path: Optional[str] = None
) -> Tuple[UsagePredictor, EfficiencyPredictor]:
    """Load usage and efficiency predictors (backward compatible)."""
    if usage_model_path is None:
        usage_model_path = Path(__file__).parent.parent.parent / "data" / "models" / "usage_predictor_v4_defense.joblib"
    if efficiency_model_path is None:
        efficiency_model_path = Path(__file__).parent.parent.parent / "data" / "models" / "efficiency_predictor_v2_defense.joblib"

    usage_predictor = UsagePredictor()
    usage_predictor.load(str(usage_model_path))

    efficiency_predictor = EfficiencyPredictor()
    efficiency_predictor.load(str(efficiency_model_path))

    logger.info(f"Loaded usage predictor from {usage_model_path}")
    logger.info(f"Loaded efficiency predictor from {efficiency_model_path}")

    return usage_predictor, efficiency_predictor


__all__ = ['PlayerSimulator', 'load_predictors', 'PlayerSimulatorV3']
